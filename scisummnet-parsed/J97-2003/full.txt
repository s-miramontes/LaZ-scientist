. Finite-state machines have been used in various domains of natural language processing. We consider here the use of a type of transducer that supports very efficient programs: sequential transducers. We recall classical theorems and give new ones characterizing sequential string-tostring transducers. Transducers that output weights also play an important role in language and speech processing. We give a specific study of string-to-weight transducers, including algorithms for determinizing and minimizing these transducers very efficiently, and characterizations of the transducers admitting determinization and the corresponding algorithms. Some applications of these algorithms in speech recognition are described and illustrated.
1.. Finite-state machines have been used in many areas of computational linguistics. Their use can be justified by both linguistic and computational arguments. Linguistically, finite automata are convenient since they allow one to describe easily most of the relevant local phenomena encountered in the empirical study of language. They often lead to a compact representation of lexical rules, or idioms and clichés, that appears natural to linguists (Gross 1989). Graphic tools also allow one to visualize and modify automata, which helps in correcting and completing a grammar. Other more general phenomena, such as parsing context-free grammars, can also be dealt with using finitestate machines such as RTN's (Woods 1970). Moreover, the underlying mechanisms in most of the methods used in parsing are related to automata. From the computational point of view, the use of finite-state machines is mainly motivated by considerations of time and space efficiency. Time efficiency is usually achieved using deterministic automata. The output of deterministic machines depends, in general linearly, only on the input size and can therefore be considered optimal from this point of view. Space efficiency is achieved with classical minimization algorithms (Aho, Hoperoft, and Ullman 1974) for deterministic automata. Applications such as compiler construction have shown deterministic finite automata to be very efficient in practice (Aho, Sethi, and Ullman 1986). Finite automata now also constitute a rich chapter of theoretical computer science (Perrin 1990). Their recent applications in natural language processing, which range from the construction of lexical analyzers (Silverztein 1993) and the compilation of morphological and phonological rules (Kaplan and Kay 1994; Karttunen, Kaplan and Zaenen 1992) to speech processing (Mohri, Pereira, and Riley 1996) show the usefulness of finite-state machines in many areas. In this paper, we provide theoretical and algorithmic bases for the use and application of the devices that support very efficient programs: sequential transducers. We extend the idea of deterministic automata to transducers with deterministic input, that is, machines that produce output strings or weights in addition to (deterministically) accepting input. Thus, we describe methods consistent with the initial reasons for using finite-state machines, in particular the time efficiency of deterministic machines, and the space efficiency achievable with new minimization algorithms for sequential transducers. Both time and space concerns are important when dealing with language. Indeed, one of the recent trends in language studies is a large increase in the size of data sets. Lexical approaches have been shown to be the most appropriate in many areas of computational linguistics ranging from large-scale dictionaries in morphology to large lexical grammars in syntax. The effect of the size increase on time and space efficiency is probably the main computational problem of language processing. The use of finite-state machines in natural language processing is certainly not new. The limitations of the corresponding techniques, however, are pointed out more often than their advantages, probably because recent work in this field is not yet described in computer science textbooks. Sequential finite-state transducers are now used in all areas of computational linguistics. In the following sections, we give an extended description of these devices. We first consider string-to-string transducers, which have been successfully used in the representation of large-scale dictionaries, computational morphology, and local grammars and syntax, and describe the theoretical bases for their use. In particular, we recall classical theorems and provide some new ones characterizing these transducers. We then consider the case of sequential string-to-weight transducers. Language models, phone lattices, and word lattices are among the objects that can be represented by these transducers, making them very interesting from the point of view of speech processing. We give new theorems extending the known characterizations of stringto-string transducers to these transducers. We define an algorithm for determinizing string-to-weight transducers, characterize the unambiguous transducers admitting determinization, and describe an algorithm to test determinizability. We also give an algorithm to minimize sequential transducers that has a complexity equivalent to that of classical automata minimization and that is very efficient in practice. Under certain restrictions, the minimization of sequential string-to-weight transducers can also be performed using the determinization algorithm. We describe the corresponding algorithm and give the proof of its correctness in the appendix. We have used most of these algorithms in speech processing. In the last section, we describe some applications of determinization and minimization of string-to-weight transducers in speech recognition, illustrating them with several results that show them to be very efficient. Our implementation of the determinization is such that it can be used on the fly: only the necessary part of the transducer needs to be expanded. This plays an important role in the space and time efficiency of speech recognition. The reduction in the size of word lattices that these algorithms provide sheds new light on the complexity of the networks involved in speech processing.
2.. Sequential string-to-string transducers are used in various areas of natural language processing. Both determinization (Mohri 1994c) and minimization algorithms (Mohri 1994b) have been defined for the class of p-subsequential transducers, which includes sequential string-to-string transducers. In this section, the theoretical basis of the use of sequential transducers is described. Classical and new theorems help to indicate the usefulness of these devices as well as their characterization. We consider here sequential transducers, namely, transducers with a deterministic input. At any state of such transducers, at most one outgoing arc is labeled with a given element of the alphabet. Figure 1 gives an example of a sequential transducer. Notice that output labels might be strings, including the empty string E. The empty string is not allowed on input, however. The output of a sequential transducer is not necessarily deterministic. The one in Figure 1 is not since, for instance, two distinct arcs with output labels b leave the state 0. Sequential transducers are computationally interesting because their use with a given input does not depend on the size of the transducer but only on the size of the input. Since using a sequential transducer with a given input consists of following the only path corresponding to the input string and in writing consecutive output labels along this path, the total computational time is linear in the size of the input, if we consider that the cost of copying out each output label does not depend on its length.
Definition. More formally, a sequential string-to-string transducer T is a 7-tuple (Q, i, F, E, A, 6 ', a), with: The functions 6 and o- are generally partial functions: a state q E Q does not necessarily admit outgoing transitions labeled on the input side with all elements of the alphabet. These functions can be extended to mappings from Q x E* by the following classical recurrence relations: Thus, a string W E E* is accepted by T iff 6(i, w) E F, and in that case the output of the transducer is cr(i, w). Sequential transducers can be generalized by introducing the possibility of generating an additional output string at final states (Schiitzenberger 1977). The application of the transducer to a string can then possibly finish with the concatenation of such an output string to the usual output. Such transducers are called subsequential transducers. Language processing often requires a more general extension. Indeed, the ambiguities encountered in language—ambiguity of grammars, of morphological analyzers, or that of pronunciation dictionaries, for instance—cannot be taken into account when using sequential or subsequential transducers. These devices associate at most a single output to a given input. In order to deal with ambiguities, one can introduce p-subsequential transducers (Mohri 1994a), namely transducers provided with at most p final output strings at each final state. Figure 2 gives an example of a 2-subsequential transducer. Here, the input string w = aa gives two distinct outputs aaa and aab. Since one cannot find any reasonable case in language in which the number of ambiguities would be infinite, p-subsequential transducers seem to be sufficient for describing linguistic ambiguities. However, the number of ambiguities could be very large in some cases. Notice that 1-subsequential transducers are exactly the subsequential transducers. Transducers can be considered to represent mappings from strings to strings. As such, they admit the composition operation defined for mappings, a useful operation that allows the construction of more complex transducers from simpler ones. The result of the application of T2 o Ti to a string s can be computed by first considering all output strings associated with the input s in the transducer Ti, then applying T2 to all of these strings. The output strings obtained after this application represent the result (T2 0 Ti) (s). In fact, instead of waiting for the result of the application of Ti to be completely given, one can gradually apply T2 to the output strings of Ti yet to be completed. This is the basic idea of the composition algorithm, which allows the transducer T2 0 Ti to be directly constructed given Ti and T2 We define sequential (resp. p-subsequential) functions to be those functions that can be represented by sequential (resp. p-subsequential) transducers. We noted previously that the result of the composition of two transducers is a transducer that can be directly constructed. There exists an efficient algorithm for the general case of the composition of transducers (transducers subsequential or not, having &transitions or not, and with outputs in E*, or in E* U fool x R-F U fool) (Mohri, Pereira, and Riley 1996). The following theorem gives a more specific result for the case of subsequential and p-subsequential functions, which expresses their closure under composition. We use the expression p-subsequential in two ways here. One means that a finite number of Example of a subsequential transducer 72. ambiguities is admitted (the closure under composition matches this case), the second indicates that this number equals exactly p. Let f: E* —> A* be a sequential (resp. p-subsequential) and g: A* -- 9* be a sequential (resp. q-subsequential) function, then g of is sequential (resp. pq-subsequential). We prove the theorem in the general case of p-subsequential transducers. The case of sequential transducers, first proved by Choffrut (1978), can be derived from the general case in a trivial way. Let T1 be a p-subsequential transducer representing f, Ti = (Qi,ii,h, E, A, 61, cri, pi), and T2 = (Q2/ i2/ F2, A, C/, 6'2, 0-2, P2) a q-subsequential transducer representing g. pi and p2 denote the final output functions of T1 and 72, which map Fi to (A*)P and F2 to (S2* )q, respectively. pi (r) represents, for instance, the set of final output strings at a final state r. Define the pq-subsequential transducer T -= (Q, i, F, E, ft 6,a, P) by Q = Qi X Q2/ i = (i1/ i2). F = {(qi,q2) E Q: qi E Fi, 82(q2, pi(qi)) n F2 01, with the following transition and output functions: and with the final output function defined by: V(qi,q2) E F, p((qi, q2)) = 0-2 (q2, pi (qi ))p2(.5(q2, pi (qi ))) Clearly, according to the definition of composition, the transducer r realizes g of. The definition of p shows that it admits at most pq distinct output strings for a given input one. This ends the proof of the theorem. 0 Figure 3 gives an example of a 1-subsequential or subsequential transducer T2. The result of the composition of the transducers Ti and 12 is shown in Figure 4. States in the transducer T3 correspond to pairs of states of Ti and T2. The composition consists essentially of making the intersection of the outputs of Ti with the inputs of 72. Transducers admit another useful operation: union. Given an input string w, a transducer union of T1 and T2 gives the set union of the strings obtained by application of Ti to w and 12 to w. We denote by Tl + T2 the union of TI and T2. The following theorem specifies the type of the transducer TI +7-2, implying in particular the closure under union of p-subsequential transducers. It can be proved in a way similar to the composition theorem. Theorem 2 Let f: E* —> A* be a sequential (resp. p-subsequential) and g: E* --> A* be a sequential (resp. q-subsequential) function, then g + f is 2-subsequential (resp. (p + q)subsequential). 2-subsequential transducer 73, obtained by composition of 71 and 12. The union transducer Ti + T2 can be constructed from Ti and 7-2 in a way close to the union of automata. One can indeed introduce a new initial state connected to the old initial states of Ti and T2 by transitions labeled with the empty string both on input and output. But the transducer obtained using this construction is not sequential, since it contains c-transitions on the input side. There exists, however, an algorithm to construct the union of p-subsequential and q-subsequential transducers directly as a p + q-subsequential transducer. The direct construction consists of considering pairs of states (qi, q), qi being a state of Ti or an additional state that we denote by an underscore, q2 a state of 7-2 or an additional state that we denote by an underscore. The transitions leaving (qi, q2) are obtained by taking the union of the transitions leaving qi and q2, or by keeping only those of qi if q2 is the underscore state, similarly by keeping only those of q2 if qi is the underscore state. The union of the transitions is performed in such a way that if qi and q2 both have transitions labeled with the same input label a, then only one transition labeled with a is associated to (qi, q2). The output label of that transition is the longest common prefix of the output transitions labeled with a leaving qi and q2. See Mohri (1996b) for a full description of this algorithm. Figure 5 shows the 2-subsequential transducer obtained by constructing the union of the transducers 7-1 and T2 this way. Notice that according to the theorem the result could be a priori 3-subsequential, but these two transducers share no common accepted string. In such cases, the resulting transducer is max(p, q)-subsequential. The linear complexity of their use makes sequential or p-subsequential transducers both mathematically and computationally of particular interest. However, not all transducers, even when they realize functions (rational functions), admit an equivalent sequential or subsequential transducer. Consider, for instance, the function f associated with the classical transducer represented in Figure 6; f can be defined by:1 VW E {X}-1-, f (w) = aim' if I w I is even, = Owl otherwise This function is not sequential, that is, it cannot be realized by any sequential transducer. Indeed, in order to start writing the output associated to an input string w a or b according to whether n is even or odd, one needs to finish reading the whole input string w, which can be arbitrarily long. Sequential functions, namely functions that can be represented by sequential transducers do not allow such unbounded delays. More generally, sequential functions can be characterized among rational functions by the following theorem: Let f be a rational function mapping E* to L. f is sequential iff there exists a positive integer K such that: The fact that not all rational functions are sequential could reduce the interest of sequential transducers. The following theorem, due to Elgot and Mezei (1965), shows, however, that transducers are exactly compositions of left and right sequential transducers. Theorem 4 (Elgot and Mezei 1965) Let f be a partial function mapping E* to A*. f is rational iff there exists a left sequential function 1: E* —> S2* and a right sequential function r: S-2* —> A* such that f =-- r 0 1. Left sequential functions or transducers are those we previously defined. Their application to a string proceeds from left to right. Right sequential functions apply to strings from right to left. According to the theorem, considering a new sufficiently large alphabet SZ allows one to define two sequential functions 1 and r that decompose a rational function f. This result considerably increases the importance of sequential functions in the theory of finite-state machines as well as in the practical use of transducers. Berstel (1979) gives a constructive proof of this theorem. Given a finite-state transducer T, one can easily construct a left sequential transducer L and a right sequential transducer R such that R o L = T. Intuitively, the extended alphabet Si keeps track of the local ambiguities encountered when applying the transducer from left to right. A distinct element of the alphabet is assigned to each of these ambiguities. The right sequential transducer can be constructed in such a way that these ambiguities can then be resolved from right to left. Figures 7 and 8 give a decomposition of the nonsequential transducer T of Figure 6. The symbols of the alphabet Q = {xl, x2} store information about the size of the input string w. The output of L ends with x1 iff I wl is odd. The right sequential function R is then easy to construct. Mohri Transducers in Language and Speech Sequential transducers offer other theoretical advantages. In particular, while several important tests, such as equivalence, are undecidable with general transducers, sequential transducers have the following decidability property Theorem 5 Let T be a transducer mapping E* to A*. It is decidable whether T is sequential. A constructive proof of this theorem was given by Choffrut (1978). An efficient polynomial algorithm for testing the sequentiability of transducers based on this proof was given by Weber and Klemm (1995). Choffrut also gave a characterization of subsequential functions based on the definition of a metric on E*. Denote by u A v the longest common prefix of two strings u and v in E*. It is easy to verify that the following defines a metric on E*: The following theorem describes this characterization of subsequential functions. Theorem 6 Let f be a partial function mapping E* to A*. f is subsequential iff: The notion of bounded variation can be roughly understood here as follows: if d(x,y) is small enough, namely if the prefix that x and y share is sufficiently long compared to their lengths, then the same is true of their images by f, f(x) and f(y). This theorem can be extended to describe the case of p-subsequential functions by defining a metric do° on (A*)P. For any u = , up) and v(vi,.. , vp) E (A*)P, we define: Assume f p-subsequential, and let T be a p-subsequential transducer realizing f. A transducer Ti, 1 < i < p, realizing a component fi off can be obtained from T simply by keeping only one of the p outputs at each final state of T. T, is subsequential by construction, hence the component fi is subsequential. Then the previous theorem implies that each component fi has bounded variation, and by definition of do°, f has also bounded variation. Conversely, if the first condition holds, a fortiori eachfi has bounded variation. This combined with the second condition implies that eachfi is subsequential. A transducer T realizing f can be obtained by taking the union of p subsequential transducers realizing each component j. Thus, in view of the theorem 2,f is p-subsequential. One can also give a characterization of p-subsequential transducers irrespective of the choice of their components. Let dp be the semimetric defined by: Let f be a rational function mapping E* to (6,*)P.f is p-subsequential iff it has bounded variation (using the semimetric dip on (A*)P). According to the previous theorem the condition is sufficient since: Conversely if f is p-subsequential, let T = (Q, i, F, E, L, 6, a, p) be a p-subsequential transducer representing f , where p = (p1,. , pp) is the output function mapping Q to (A*)P. Let N and M be defined by: We denote by Dom(T) the set of strings accepted by T. Let k > 0 and (ui, u2) E [Dom(T)12 such that d(ui, u2) <k. Then, there exists u E E* such that: Thus, f has bounded variation using dip. This ends the proof of the theorem. We briefly mentioned several theoretical and computational properties of sequential and p-subsequential transducers. These devices are used in many areas of computational linguistics. In all those areas, the determinization algorithm can be used to obtain a p-subsequential transducer (Mohri 1996b), and the minimization algorithm to reduce the size of the p-subsequential transducer used (Mohri 1994b). The composition, union, and equivalence algorithms for subsequential transducers are also useful in many applications. Mohri Transducers in Language and Speech 2.4.1 Representation of Dictionaries. Very large-scale dictionaries can be represented by p-subsequential dictionaries because the number of entries and that of the ambiguities they contain are finite. The corresponding representation offers fast look-up since the recognition does not depend on the size of the dictionary but only on that of the input string considered. The minimization algorithm for sequential and p-subsequential transducers allows the size of these devices to be reduced to the minimum. Experiments have shown that these compact and fast look-up representations for large natural language dictionaries can be efficiently obtained. As an example, a French morphological dictionary of about 21.2 Mb can be compiled into a p-subsequential transducer of 1.3 Mb, in a few minutes (Mohri 1996b). 2.4.3 Syntax. Finite-state machines are also currently used to represent local syntactic constraints (Silberztein 1993; Roche 1993; Karlsson et al. 1995; Mohri 1994d). Linguists can conveniently introduce local grammar transducers that can be used to disambiguate sentences. The number of local grammars for a given language and even for a specific domain can be large. The local grammar transducers are mostly p-subsequential. Determinization and minimization can then be used to make the use of local grammar transducers more time efficient and to reduce their size. Since p-subsequential transducers are closed under composition, the result of the composition of all local grammar transducers is a p-subsequential transducer. The equivalence of local grammars can also be tested using the equivalence algorithm for sequential transducers. For a more detailed overview of the applications of sequential string to string transducers to language processing, see Mohri (1996a). Because they are so time and space efficient, sequential transducers will likely be used increasingly often in natural language processing as well as in other connected fields. In the following, we consider the case of string-to-weight transducers, which are also used in many areas of computational linguistics. We consider string-to-weight transducers, namely transducers with input strings and output weights. These transducers are used in various domains, such as language modeling, representation of word or phonetic lattices, etc., in the following way: one reads and follows a path corresponding to a given input string and outputs a number obtained by combining the weights along this path. In most applications to natural language processing, the weights are simply added along the path, since they are interpreted as (negative) logarithms of probabilities. In case the transducer is not sequential, that is, when it does not have a deterministic input, one proceeds in the same way for all the paths corresponding to the input string. In natural language processing, specifically in speech processing, one keeps the minimum of the weights associated to these paths. This corresponds to the Viterbi approximation in speech recognition or in other related areas for which hidden Markov models (HMM's) are used. In all such applications, one looks for the best path, i.e., the path with the minimum weight. In this section, we give the definition of string-to-weight transducers and other definitions useful for the presentation of the theorems of the following sections. In addition to the output weights of the transitions, string-to-weight transducers are provided with initial and output weights. For instance, when used with the input string ab, the transducer in Figure 9 outputs: 5 + 1 + 2 + 3 = 11, 5 being the initial and 3 the final weight. More formally, a string-to-weight transducer T is defined by T = (Q, E, I, F, E, A, p) with: One can define for T a transition (partial) function S mapping Q x E to 2Q by: V (q, a) E Q x E, (q , a) = fq' I 3x E (q, a, x, q') e El and an output function a mapping E to R. by: A path 7 in T from q E Q to q' c Q is a set of successive transitions from q to q': 7r = ((q0,ao,x0, qi), • • • , (qm—i,am_i, xm_i, qm)), with Vi E [0, M — 11, q,±1 E 6(q11at). We can extend the definition of a to paths by: a(x) = xoxi • x-i. We denote by 7r e q q' the set of paths from q to q' labeled with the input string w. The definition of S can be extended to Q x E* by: V(q, EQ x E*,(5(q,w) = {q': path 7r in T,7r E q q'} Mohri Transducers in Language and Speech and to 2(2 x E*, by: For (q, w, q') E QxExQ such that there exists a path from q to q' labeled with w, we define 9(q, w, q') as the minimum of the outputs of all paths from q to q' with input w: A successful path in T is a path from an initial state to a final state. A string w E E* is accepted by T if there exists a successful path labeled with w: w E S(I,w) n F. The output corresponding to an accepted string w is then obtained by taking the minimum of the outputs of all successful paths with input label w: A transducer T is said to be trim if all states of T belong to a successful path. String-toweight transducers clearly realize functions mapping E* to 12.±. Since the operations we need to consider are addition and min, and since (74 U { oo }, min, +, oo, 0) is a semiring, we call these functions formal power series.' We adopt the terminology and notation used in formal language theory (Berstel and Reutenauer 1988; Kuich and Salomaa 1986; Salomaa and Soittola 1978): The fundamental theorem of Schutzenberger (1961), analogous to Kleene's theorem for formal languages, states that a formal power series S is rational iff it is recognizable, that is, realizable by a string-to-weight transducer. The semiring (R.+ U { °e}, min, +, 00, 0) used in many optimization problems is called the tropical semiring.3 So, the functions we consider here are more precisely rational power series over the tropical semiring. A string-to-weight transducer T is said to be unambiguous if for any given string w there exists at most one successful path labeled with w. In the following, we examine, more specifically, efficient string-to-weight transducers: subsequential transducers. A transducer is said to be subsequential if its input is deterministic, that is if at any state there exists at most one outgoing transition labeled with a given element of the input alphabet E. Subsequential string-to-weight transducers are sometimes called weighted automata, or weighted acceptors, or probabilistic automata, or distance automata. Our terminology is meant to favor the functional view of these devices, which is the view that we consider here. Not all string-to-weight transducers are subsequential but we define an algorithm to determinize nonsubsequential transducers when possible. More formally a string-to-weight subsequential transducer T = (Q, i, F, E, (5, a, A, p) is an 8-tuple, with: A string w E E* is accepted by a subsequential transducer T if there exists f E F such that (5(i, w) = f . The output associated to w is then: A + cr(i, w) + p(f). We will use the following definition for characterizing the transducers that admit determinization. Two states q and q' of a string-to-weight transducer T = (Q, I, F, E, 6, a, A, p), not necessarily subsequential, are said to be twins if: In other words, q and q' are twins if, when they can be reached from the initial state by the same string u, the minimum outputs of loops at q and q' labeled with any string v are identical. We say that T has the twins property when any two states q and q' of T are twins. Notice that according to the definition, two states that do not have cycles with the same string v are twins. In particular, two states that do not belong to any cycle are necessarily twins. Thus, an acyclic transducer has the twins property In the following section, we consider subsequential power series in the tropical semiring, that is, functions that can be realized by subsequential string-to-weight transducers. Many rational power series defined on the tropical semiring considered in practice are subsequential, in particular, acyclic transducers represent subsequential power series. Mohri Transducers in Language and Speech We introduce a theorem giving an intrinsic characterization of subsequential power series irrespective of the transducer realizing them. We then present an algorithm that allows one to determinize some string-to-weight transducers. We give a general presentation of the algorithm since it can be used with many other semirings, in particular, with string-to-string transducers and with transducers whose output labels are pairs of strings and weights. We then use the twins property to define a set of transducers to which the determinization algorithm applies. We give a characterization of unambiguous transducers admitting determinization, and then use this characterization to define an algorithm to test if a given transducer can be determinized. We also present a very efficient minimization algorithm that applies to subsequential string-to-weight transducers. In many cases, the determinization algorithm can also be used to minimize a subsequential transducer; we describe this use of the algorithm and give the related proofs in the appendix. Recall that one can define a metric on E* by: where we denote by u A v the longest common prefix of two strings u and v in E*. The definition we gave for subsequential power series depends on the transducers representing them. The theorem that follows gives an intrinsic characterization of subsequential power series.' Theorem 9 Let S be a rational power series defined on the tropical semiring. S is subsequential iff it has bounded variation. Proof Assume that S is subsequential. Let T = (Q, i, F, E, 6,0•, A, p) be a subsequential transducer. 8 denotes the transition function associated with 7-, a its output function, and A and p the initial and final weight functions. Let L be the maximum of the lengths of all output labels of T: and R the upper bound of all output differences at final states: and define M as M -= L + R. Let (ui, u2) be in (E*)2. By definition of d, there exists U E E* such that: This proves that S is M-Lipschitzian5 and a fortiori that it has bounded variation. Conversely, suppose that S has bounded variation. Since S is rational, according to the theorem of Schtitzenberger (1961) it is recognizable and therefore there exists a string-to-weight transducer 7- = (Q, I, F, E, 6, a, p) realizing S. As in the case of string-to-string transducers, one can show that any transducer admits an equivalent trim unambiguous transducer. So, without loss of generality we can assume T trim and unambiguous. Furthermore, we describe in the next sections a determinization algorithm. We show that this algorithm applies to any transducer that has the twins property Thus, in order to show that S is subsequentiable, it is sufficient to show that T has the twins property Consider two states q and q' of T and let (u, v) E (E* )2 be such that: Since T is trim there exists (w, w') E (E*)2 such that 6(q, w) n F 0 and 6 (q, w') n F 0. Notice that Vk > 0, d(uvkw, uvkw') d(w, w1) Thus, since S has bounded variation Algorithm for the determinization of a transducer Ti representing a power series defined on the semiring (S, G, 6, 1) . Hence We describe in this section an algorithm for constructing a subsequential transducer 72 = (Q2, 2,F2, E, 62, 0-2, A2,192) equivalent to a given nonsubsequential one TI E, I, F1, Ei, A1, P1). The algorithm extends our determinization algorithm for stringto-string transducers representing p-subsequential functions to the case of transducers outputting weights (Mohri 1994c). Figure 10 gives the pseudocode of the algorithm. We present the algorithm in the general case of a semiring (S, ED, 0, 0, 1) on which the transducer Ti is defined. Indeed, the algorithm we are describing here applies as well to transducers representing power series defined on many other semirings.6 We describe the algorithm in the case of the tropical semiring. For the tropical semiring, one can replace ED by min and 0 by + in the pseudocode of Figure 10.7 The algorithm is similar to the powerset construction used for the determinization of automata. However, since the outputs of two transitions bearing the same input label might differ, one can only output the minimum of these outputs in the resulting transducer, therefore one needs to keep track of the residual weights. Hence, the subsets q2 that we consider here are made of pairs (q, x) of states and weights. The initial weight A2 Of 72 is the minimum of all the initial weights of TI (line 2). The initial state i2 is a subset made of pairs (i, x), where i is an initial state of and x = A1 (i) — A2 (line 3). We use a queue Q to maintain the set of subsets q2 yet to be examined, as in the classical powerset construction.' Initially, Q contains only the subset i2. The subsets q2 are the states of the resulting transducer. q2 is a final state of 7-2 iff it contains at least one pair (q, x), with q a final state of ri (lines 7-8). The final output associated to q2 is then the minimum of the final outputs of all the final states in q2 combined with their respective residual weight (line 9). For each input label a such that there exists at least one state q of the subset q2 admitting an outgoing transition labeled with a, one outgoing transition leaving q2 with the input label a is constructed (lines 10-14). The output 0-2(q2, a) of this transition is the minimum of the outputs of all the transitions with input label a that leave a state in the subset q2, when combined with the residual weight associated to that state (line 11). The destination state 62(q2, a) of the transition leaving q2 is a subset made of pairs (q', x'), where q' is a state of Ti that can be reached by a transition labeled with a, and x' the corresponding residual weight (line 12). x' is computed by taking the minimum of all the transitions with input label a that leave a state q of q2 and reach q', when combined with the residual weight of q minus the output weight C72 (q2, a). Finally, 62(q2, a) is enqueued in Q iff it is a new subset. We denote by n1 (t) the destination state of a transition t E Ei. Hence n1 (t) q' , if t = (q, a, x, q') E Ei. The sets r(q2, a), of(q2, a), and v(q2, a) used in the algorithm are defined by: (q2, a) denotes the set of pairs (q, x), elements of the subset q2, having transitions labeled with the input a. 7(q2, a) denotes the set of triples (q, x, t) where (q, x) is a pair in q2 such that q admits a transition with input label a. v(q2, a) is the set of states q' that can be reached by transitions labeled with a from the states of the subset q2. The algorithm is illustrated in Figures 11 and 12. Notice that the input ab admits several outputs in pi: {1 + 1 = 2,1 + 3 = 4,3 + 3 = 6,3 + 5 -= 8}. Only one of these outputs (2, the smallest) is kept in the determinized transducer /12, since in the tropical semiring one is only interested in the minimum outputs for any given string. Notice that several transitions might reach the same state with a priori different residual weights. Since one is only interested in the best path, namely the path corresponding to the minimum weight, one can keep the minimum of these weights for a given state element of a subset (line 11 of the algorithm of Figure 10). In the next section, we give a set of transducers TI for which the determinization algorithm terminates. The following theorem shows the correctness of the algorithm when it terminates. Transducer it2 obtained by power series determinization of Theorem 10 Assume that the determinization algorithm terminates, then the resulting transducer 72 is equivalent to r1. We denote by Oi(q,w, q') the minimum of the outputs of all paths from q to q'. By construction we have: We define the residual output associated to q in the subset 62(i2, w) as the weight c(q, w) associated to the pair containing q in 82 (i2, w). It is not hard to show by induction on I wl that the subsets constructed by the algorithm are the sets 62 (i2, W E E*, such that: Notice that the size of a subset never exceeds I Qi I: card(62(i2, w)) < I Qi. A state q belongs at most to one pair of a subset, since for all paths reaching q, only the minimum of the residual outputs is kept. Notice also that, by definition of mm, in any subset there exists at least one state q with a residual output c(q, w) equal to 0. A string w is accepted by Ti iff there exists q E F1 such that q E 61(Ii,w). Using equations 15, it is accepted if 62(i2, w) contains a pair (q,c(q,w)) with q E Fi. This is exactly the definition of the final states F2 (line 7). So 7-1 and T2 accept the same set of strings. Let w E E* be a string accepted by ri and T2. The definition of p2 in the algorithm of figure 10, line 9, gives: The power series determinization algorithm is equivalent to the usual determinization of automata when the initial weight, the final weights, and all output labels are equal to 0. The subsets considered in the algorithm are then exactly those obtained in the powerset determinization of automata, all residual outputs c(q, w) being equal to 0. Both space and time complexity of the determinization algorithm for automata are exponential. There are minimal deterministic automata with exponential size with respect to an equivalent nondeterministic one. A fortiori the complexity of the determinization algorithm in the weighted case we just described is also exponential. However, in some cases in which the degree of nondeterminism of the initial transducer is high, the determinization algorithm turns out to be fast and the resulting transducer has fewer states than the initial one. We present examples of such cases, which appear in speech recognition, in the last section. We also present a minimization algorithm that allows the size of subsequential transducers representing power series to be reduced. The complexity of the application of subsequential transducers is linear in the size of the string to which it applies. This property makes it worthwhile to use the power series determinization to speed up the application of transducers. Not all transducers can be determinized using the power series determinization. In the following section, we define a set of transducers that admit determinization, and characterize unambiguous transducers that admit the application of the algorithm. Since determinization does not apply to all transducers, it is important to be able to test the determinizability of a transducer. We present, in the next section, an algorithm to test this property in the case of unambiguous trim transducers. The proofs of some of the theorems in the next two sections are complex; they can be skipped on first reading. There are transducers with which determinization does not halt, but rather generates an infinite number of subsets. We define determinizable transducers as those transducers with which the algorithm terminates. We first show that a large set of transducers Mohri Transducers in Language and Speech admit determinization, then give a characterization of unambiguous transducers admitting determinization. In what follows, the states of the transducers considered will be assumed to be accessible from the initial one. The following lemma will be useful in the proof of the theorems. Lemma 1 Let T = (Q, E, I, F, E, A, p) be a string-to-weight transducer, 7r E p q a path in T from the state p E Q to q E Q, and 7r' E p' q' a path from p' E Q to q' E Q both labeled with the input string w E E*. Assume that the lengths of it and 7r' are greater than We also define A and p by: V(ii, t2) E h x A(ii, i2) = A2(i2)), V(fj,,,f2) E Fi x F2, P(fi,f2) -= (Pi(fi ), P2(f2)). Consider the cross product of T with itself, T x T. Let it and 713 be two paths in T with lengths greater than 1Q12 - 1, (m> 1Q12 - 1): is a path in T x T with length greater than 1Q12 - 1. Since T x T has exactly 1Q12 states, H admits at least one cycle at some state (p1,p'i) labeled with a non-empty input string u2. This shows the existence of the factorization above and proves the lemma. 0 Let TI = (Q1, E, 111F1, Ei, Ai, p1) be a string-to-weight transducer defined on the tropical semirirtg. If 7-1 has the twins property then it is determinizable. Proof Assume that 7- has the twins property. If the determinization algorithm does not halt, there exists at least one subset of 2, {q0, , q„,}, such that the algorithm generates an infinite number of distinct weighted subsets {(qo, c0), • • (q„„ . Then we have necessarily m > 1. Indeed, we mentioned previously that in any subset there exists at least one state qi with a residual output c, = 0. If the subset contains only one state go, then co = 0. So there cannot be an infinite number of distinct subsets { (go, co )} • Let A C E* be the set of strings w such that the states of 62(i2, w) be Iqo, • • • , 1. We have: Vw E A, 62(i2,w) = {(q0, c(qo,w)), • • • , (qm, c(q,n,w))1 . Since A is infinite, and since in each weighted subset there exists a null residual output, there exist io, 0 < io <m, such that c(q,,„w) = 0 for an infinite number of strings w E A. Without loss of generality we can assume that io =- 0. Let B C A be the infinite set of strings w for which c(q0,w) = 0. Since the number of subsets {(go, c(go, w)), • • • (qm, c(gm, w))}, w E B, is infinite, there exists], 0 <j < m, such that c(qj,w) be distinct for an infinite number of strings w E B. Without loss of generality we can assume j = 1. Let C C B be an infinite set of strings w with c(qi,w) all distinct. Define R(qo, qi) to be the finite set of differences of the weights of paths leading to go and gi labeled with the same string w, < IwIIQiI2-1: We will show that {c(gi, w): w E C} C R(q0, qi). This will yield a contradiction with the infinity of C, and will therefore prove that the algorithm terminates. Let w E C, and consider a shortest path 7ro from a state 10 E I to qo labeled with the input string w and with total cost cr(7r0). Similarly consider a shortest path in from E Ito gi labeled with the input string w and with total cost cr(n-i). By definition of the subset construction we have: (A(i1) + cr(71-1)) — (A(io) cr(71-0)) = c(qi,w). Assume that w I > 112112 — 1. Using the lemma 1, there exists a factorization of 7r0 and iti of the type: Since in and 7T/ are shortest paths, we have: O(7n0) = o-(71-) + 01(Po, u2,po) and 0*(70 = c(lri)±01 (pi, u2, pi). Hence: (A(ii)+0(7r)) — (.\(io)±(7(4)) = c(qi,w). By induction on 170, we can therefore find shortest paths Ho and 1-11 from 10 to qo (resp. ii to gi) with length less or equal to l(2112 —1 and such that (A(ii)+a(111)) — (A(io)+0-(11o)) = c(ql, w). Since c(I11) — cr(II0) E R(q0, qi), c(qi,w) E R(q0, qi) and C is finite. This ends the proof of the theorem. 0 There are transducers that do not have the twins property and that are still determinizable. To characterize such transducers, more complex conditions that we will not describe here are required. However, in the case of trim unambiguous transducers, the twins property provides a characterization of determinizable transducers. Let Ti = (Q1, E, /1, F1, Ei, Ai, Pi) be a trim unambiguous string-to-weight transducer defined on the tropical semiring. Then Ti is determirtizable iff it has the twins property. Proof According to the previous theorem, if T.1 has the twins property, then it is determinizable. Assume now that T does not have the twins property, then there exist at least two states q and q' in Q that are not twins. There exists (u, v) E E* such that: ({q, q'} c SW, u), q E 61(q,v),q' E 81(qcv)) and 01(q, v, q) 01(q' ,v, q'). Consider the weighted subsets 52(i2, UVk), with k E Ai, constructed by the determinization algorithm. A subset 62(i2, uv&quot;) contains the pairs (q, c(q, uvk)) and (q', c(q', uvk)). We will show that these subsets are all distinct. This will prove that the determinization algorithm does not terminate if Ti does not have the twins property. Since ri is a trim unambiguous transducer, there exits only one path in Ti from I to q or to q' with input string u. Similarly, the cycles at q and q' labeled with v are unique. Thus, there exist i E I and i' E I such that: Since 0 0 0, equation 20 shows that the subsets 62(i2, uv') are all distinct. 0 The characterization of determinizable transducers provided by theorem 12 leads to the definition of an algorithm for testing the determinizability of trim unambiguous transducers. Before describing the algorithm, we introduce a lemma that shows that it suffices to examine a finite number of paths to test the twins property. Lemma 2 Let Ti = (Qi, E, Ii, Fi, Ei, Ai, Pi) be a trim unambiguous string-to-weight transducer defined on the tropical serniring. Ti has the twins property iff V(u, V) E (E*)2,1UVI < Clearly if Ti has the twins property, then (21) holds. Conversely, we prove that if (21) holds, then it also holds for any (u, v) E (E* )2, by induction on I uv. Our proof is similar to that of Berstel (1979) for string-to-string transducers. Consider (u, v) E (E*)2 and (q, q') E l(2112 such that: {q, q'} c I (I, u), q c 61(q, v), q' E (q' , v). Assume that luvl > 21(2112 — 1 with Ivl > 0. Then either lul > Assume that I u I > 1(21 12 - 1. Since Ti is a trim unambiguous transducer there exists 1(2112 — 1 or Iv' a unique path 7r in Ti from i E Ito q labeled with the input string u, and a unique path > 1Q112 — 1. 7r' from i' E Ito q'. In view of lemma 2, there exist strings 141, u2, u3 in E*, and states pi, p2, p, and p12 such that I u2I > 0, u1u2u3 = u and such that ir and ir' be factored in the following way: Next, assume that lvi > 1Q112 -1. Then according to lemma 1, there exist strings v1, v2, V3 in E*, and states qi, q2, q'y and q'2 such that Iv2I > 0, v1v2v3 = v and such that Ir and 71-' be factored in the following way: Let T1 -= E1, A1,101) be a trim unambiguous string-to-weight transducer defined on the tropical semiring. There exists an algorithm to test the determinizability of Ti. Proof According to theorem 12, testing the determinizability of TI is equivalent to testing for the twins property We define an algorithm to test this property Our algorithm is close to that of Weber and Klemm (1995) for testing the sequentiability of string-to-string transducers. It is based on the construction of an automaton A = (Q, I, F, E) similar to the cross product of Ti with itself. Let K C 7?, be the finite set of real numbers defined by: Mohri Transducers in Language and Speech By construction, two states qi and q2 of Q can be reached by the same string u, lul < 21(2112 — 1, if there exists c E K such that (qi, q2, c) can be reached from / in A. The set of such (qi, q2, c) is exactly the transitive closure of I in A. The transitive closure of I can be determined in time linear in the size of A, 0(1(21 + I E I). Two such states qi and q2 are not twins if there exists a path in A from (eh, q2, 0) to (qi, q2, c), with c 0. Indeed, this is exactly equivalent to the existence of cycles at qi and q2 with the same input label and distinct output weights. According to lemma 2, it suffices to test the twins property for strings of length less than 21(2112 — 1. So the following gives an algorithm to test the twins property of a transducer The operations used in the algorithm (computation of the transitive closure, determination of the set of states) can all be done in polynomial time with respect to the size of A, using classical algorithms (Aho, Hoperoft, and Ullman 1974). 0 This provides an algorithm for testing the twins property of an unambiguous trim transducer T. It is very useful when T is known to be unambiguous. In many practical cases, the transducer one wishes to determinize is ambiguous. It is always possible to construct an unambiguous transducer T' from T (Eilenberg 1974-1976). The complexity of such a construction is exponential in the worst case. Thus the overall complexity of the test of determinizability is also exponential in the worst case. Notice that if one wishes to construct the result of the determinization of T for a given input string w, one does not need to expand the whole result of the determinization, but only the necessary part of the determinized transducer. When restricted to a finite set the function realized by any transducer is subsequentiable, since it has bounded variation.' Acyclic transducers have the twins property, so they are determinizable. Therefore, it is always possible to expand the result of the determinization algorithm for a finite set of input strings, even if T is not determinizable. The determinization algorithm that we previously presented applies as well to transducers mapping strings to other semirings. We gave the pseudocode of the algorithm in the general case. The algorithm applies for instance to the real semiring (R,,+,., 0,1). One can also verify that (E*Uf oo}, A, oo, f), where A denotes the longest common prefix operation and • concatenation, oo a new element such that for any string w E (E*U fool), WA oo = co A w = w and w oo oo • w = oo, defines a left semiring.' We call this semiring the string semiring. The algorithm of Figure 10 used with the string semiring is exactly the determinization algorithm for subsequentiable string-to-string transducers, as defined by Mohri (1994c). The cross product of two semirings defines a semiring. The algorithm also applies when the semiring is the cross product of Sequential transducer 72 with outputs in E* x R obtained from (31 by determinization. (E* U fool, A, oo, €) and (R+ U { oo }, min, +, 00, 0), which allows transducers outputting pairs of strings and weights to be determined. The determirtization algorithm for such transducers is illustrated in Figures 13 and 14. Subsets in this algorithm are made of triples (q, w, x) E Q x E* U { oo} x R. U foo}, where q is a state of the initial transducer, w a residual string, and x a residual output weight. We here define a minimization algorithm for subsequential power series defined on the tropical semiring, which extends the algorithm defined by Mohri (1994b) in the case of string-to-string transducers. For any subset L of E* and any string u we define it-lL by: 11 One can prove that S. a power series defined on a field, is rational if it admits a finite number of independent u-1S (Carlyle and Paz 1971). This is the equivalent, for power series, of Nerode's theorem for regular languages. Mohri Transducers in Language and Speech For any subsequential power series S we can now define the following relation on E*: It is easy to show that Rs is an equivalence relation. (u-1 supp(S) = supp(S)) defines the equivalence relation for regular languages. Rs is a finer relation. The additional condition in the definition of Rs is that the restriction of the power series [14-1S - v-1S] to u-1 supp(S) = supp(S) is constant. The following lemma shows that if there exists a subsequential transducer T computing S with a number of states equal to the number of equivalence classes of Rs, then T is a minimal transducer computing f. If S is a subsequential power series defined on the tropical semiring, Rs has a finite number of equivalence classes. This number is bounded by the number of states of any subsequential transducer realizing S. So V(u, v) E (E*)2, 6(i, u) = 6(i, v) = (uRsv). This proves the lemma. 0 The following theorem proves the existence of a minimal subsequential transducer representing S. For any subsequential function S, there exists a minimal subsequential transducer computing it. Its number of states is equal to the index of R. Given a subsequential power series S, we define a power series f by: We then define a subsequential transducer T = (Q, i, F, E, 6,a, A, p) by:12 Since the index of Rs is finite, Q and F are well-defined. The definition of 6 does not depend on the choice of the element u in U, since for any a E E, u Rs v implies (ua) Rs (va). The definition of a is also independent of this choice, since by definition of Rs, if uRsv, then (ua) Rs (va) and there exists k E R. such that Vw E E*, (S, uaw) (S. yaw) = (S, uw) - (S, vw) = k. Notice that the definition of a implies that: T realizes S. This ends the proof of the theorem. 0 Given a subsequential transducer T = (Q, i,F , E, 6, a, A, p), we can define for each state q E Q, d(q) by: We define a new operation of pushing, which applies to any transducer T. In particular, if T is subsequential the result of the application of pushing to T is a new subsequential transducer T' = (Q, i,F , E, 6, , A', p') that only differs from T by its output weights in the following way: According to the definition of d, we have: Mohri Transducers in Language and Speech Lemma 4 Let T' be the transducer obtained from T by pushing. T' is a subsequential transducer which realizes the same function as T. This proves the lemma. 0 The following theorem defines the minimization algorithm. Let T be a subsequential transducer realizing a power series on the tropical semiring. Then applying the following two operations: leads to a minimal transducer. This minimal transducer is exactly the one defined in the proof of theorem 14. The automata minimization step in the theorem consists of considering pairs of input labels and associated weights as a single label and of applying classical minimization algorithms for automata (Aho, Hoperoft, and Ullman 1974). We do not give the proof of the theorem; it can be proved in a way similar to what is indicated in Mohri (1994b). In general, there are several distinct minimal subsequential transducers realizing the same function. Pushing introduces an equivalence relation on minimal transducers: T Rp T' if p(T) -= p(T'), where p(T) (resp. p(T')) denotes the transducer obtained from T (resp. T') by pushing. Indeed, if T and T' are minimal transducers realizing the same function, then p(T) and p(T') are both equal to the unique minimal transducer equivalent to T and T' as defined in theorem 14. So, two equivalent minimal transducers only differ by their output labels, they have the same topology. They only differ by the way the output weights are spread along the paths. Notice that if we introduce a new super final state 43 to which each final state q is connected by a transition of weight p(q), then d(q) in the definition of T' is exactly the length of a shortest path from .11 to q. Thus, T' can be obtained from T using the classical single-source shortest paths algorithms such as that of Dijkstra (Cormen, Leiserson, and Rivest 1992).13 lit case the transducer is acyclic, a classical linear time algorithm based on a topological sort of the graph allows one to obtain d. Once the function d is defined, the transformation of T into T' can be done in linear time, namely 0(1(21+IED, if we denote by E the set of transitions of T. The complexity of pushing is therefore linear (0(1Q1+1E1)) if the transducer is acyclic. In the general case, the complexity of pushing is 0(1Ellog IQ') if we use classical heaps, 0(1E1 + IQ' log 1 (21 ) if we use Fibonacci heaps, and 0(1Ellog log IQ) if we use the efficient implementation of priority queues by Thorup (1996). In case the maximum output weight W is small, we can use the algorithm of Ahuja et al. (1988); the complexity of pushing is then 0(1E1+ 1(21-0w1). In case the transducer is acyclic, we can use a specific automata minimization algorithm (Revuz 1992) with linear time complexity, 0(1(21 + 1E1). In the general case, an efficient implementation of Hoperoft's algorithm (Aho, Hoperoft, and Ullman 1974) leads to 0(1ElloglQ1). Thus, the overall complexity of the minimization of subsequential transducers is always as good as that of classical automata minimization: 0(1(21 + 1El) in the acyclic case, and 0(1Ellog1Q1) in the general case. Figures 15 to 17 illustrate the minimization algorithm. 31 (Figure 15) represents a subsequential string-to-weight transducer. Notice that the size of )31 cannot be reduced using the automata minimization. represents the transducer obtained by pushing, and Si a minimal transducer realizing the same function as 31 in the tropical semiring. Minimal transducer 61 obtained from 71 by automata minimization. The transducer obtained by this algorithm is the one defined in the proof of theorem 14 and has the minimal number of states. This raises the question of whether there exists a subsequential transducer with the minimal number of transitions and computing the same function as a given subsequential transducer T. The following corollary offers an answer. Corollary 1 A minimal subsequential transducer has also the minimal number of transitions among all subsequential transducers realizing the same function. This generalizes the analogous theorem that holds in the case of automata. The proof is similar. Let T be a subsequential transducer with a minimal number of transitions. Clearly, pushing does not change the number of transitions of T and automatan minimization, which consists of merging equivalent states, reduces or does not change this number. Thus, the number of transitions of the minimal transducer equivalent to T as previously defined is less or equal to that of T. This proves the corollary since, as previously pointed out, equivalent minimal transducers all have the same topology: in particular, they have the same number of states and transitions. Given two subsequential transducers, one might wish to test their equivalence. The importance of this problem was pointed out by Hoperoft and Ullman (1979, 284). The following corollary addresses this question. Corollary 2 There exists an algorithm to determine if two subsequential transducers are equivalent. The algorithm of theorem 15 associates a unique minimal transducer to each subsequential transducer T. More precisely, this minimal transducer is unique up to a renumbering of the states. The identity of two subsequential transducers with different numbering of states can be tested in the same way as that of two deterministic automata; for instance, by testing the equivalence of the automata and the equality of their number of states. An efficient algorithm for testing the equivalence of two deterministic automata is given in Aho, Hoperoft, and Ullman (1974).14 Since the minimization of subsequential transducers was also shown to be efficient, this proves the corollary and also the efficiency of the test of equivalence. 0 Schiitzenberger (1961) gave an algorithm for minimizing the representation of power series, but this algorithm can only be used when the semiring considered is a field. In particular, it cannot be used with the tropical semiring or the string semiring used in language and speech processing, since none of these semirings is a field. More precisely, a recent result of Krob (1994) states that such a minimization cannot be defined for transducers defined on the tropical semiring. Furthermore, we implemented the algorithm of Schatzenberger (1961) and used it in the case of the semiring (R., +, 0,1). It has two important disadvantages in practice: it creates many transitions, and it can generate transitions with negative weights, even if the initial machine has none. The negative weights cannot be interpreted in terms of probability. In the next section, we describe some of the applications to speech recognition of the algorithms we presented above.
4.. In previous sections, we gave a theoretical description of the determinization and minimization algorithms for string-to-weight transducers. Here we indicate their use in practice. These algorithms have interesting applications in speech recognition, some of which we briefly point out below. String-to-weight transducers are found at several stages of speech recognition. Phone lattices, language models, and word lattices are typically represented by such transducers. Weights in these graphs correspond to negative logarithms of probabilities. They are added along a path. For a given string, there might be many different paths in a transducer. Only the minimum of the total weights of these paths is considered relevant. Thus, the main operations involved in the interpretation of these transducers are addition and min, namely those of the tropical semiring. Thus, the algorithms we defined in the previous sections apply to speech recognition. The domain of the speech recognition systems above signal processing can be represented by a composition of finite-state transducers outputting weights, or both strings and weights (Pereira and Riley 1996; Mohri, Pereira, and Riley 1996): GoL 0 Co A 0 where 0 represents the acoustic observations, A the acoustic model mapping sequences of acoustic observations to context-dependent phones, C the context-dependency model mapping sequences of context-dependent phones to (context-independent) phones, L a pronunciation dictionary mapping sequences of phones to words, and G a language model or grammar mapping sequences of words to sentences. In general, this cascade of compositions cannot be explicitly expanded, because of the large size of the compositions; an approximation method is required to search it. Often, a beam pruning is used: only paths with weights within the beam (the difference of the weights from the minimum weight so far is less than a certain predefined threshold) are kept during the expansion of the cascade of composition. Furthermore, only the best path or a set of paths of the cascade of transducers with the lowest weights is of interest. A set of paths with the lowest weights can be represented by an acyclic string-toweight transducer, each path of which corresponds to a sentence. The weight of the path can be interpreted as a negative log of the probability of that sentence given the sequence of acoustic observations (utterance). Such acyclic string-to-weight transducers are called word lattices. For a given utterance, the word lattice obtained in such a way contains many paths labeled with the possible sentences and their associated weights. A word lattice often contains a lot of redundancy: many paths correspond to the same sentence but with different weights. Word lattices can be directly searched to find the most probable sentences, those which correspond to the best paths, the paths with the smallest weights. Figure 18 shows a word lattice obtained in speech recognition for the 2,000-word ARPA ATIS Task. It corresponds to the following utterance: Which flights leave Detroit and arrive at Saint Petersburg around nine am? Clearly the lattice is complex; it contains about 83 million paths. Usually, it is not enough to consider the best path of a word lattice. It is also necessary to correct the best path approximation by considering the n best paths, where the value of n depends on the task considered. Notice that in case n is very large, one would need to consider, for the lattice in Figure 18, all 83 million paths. The transducer contains 106 states and 359 transitions. Determinization applies to this lattice. The resulting transducer W2 (Figure 19) is sparser. Recall that it is equivalent to W1, realizing exactly the same function mapping strings to weights. For a given sentence s recognized by WI, there are many different paths with different total weights. W2 contains a path labeled with s and with a total weight equal to the minimum of the weights of the paths of W1. Let us insist on the fact that no pruning, heuristic, or approximation has been used here. The lattice W2 only contains 18 paths. Obviously, the search stage in speech recognition is greatly simplified when applied to W2 rather than Wi. W2 admits 38 states and 51 transitions. The transducer W2 can still be minimized. The minimization algorithm described in the previous section leads to the transducer W3 shown in Figure 20. It contains 25 states and 33 transitions and of course the same number of paths as W2, 18. The effect of minimization appears to be less important. This is because, in this case, determinization includes a large part of the minimization by reducing the size of the first lattice. This can be explained by the degree of nondeterminism of word lattices such as WI.' Many states can be reached by the same set of strings. These states are grouped into a single subset during determinization. Also, the complexity of determinization is exponential in general, but in the case of the lattices considered in speech recognition, it is not.16 Since they contain a lot of redundancy, the resulting lattice is smaller than the initial one. In fact, the time complexity of determinization can be expressed in terms of the initial and resulting lattices, W1 and W2, by 0(1E I log II(1W1I1W21)2), where I Wi I and 114,721 denote the sizes of W1 and W2. Clearly if we restrict determinization to the cases where 1W2 I I W1 its complexity is polynomial in terms of the size of the initial transducer I Wi I. This also applies to the space complexity of the algorithm. In practice, the algorithm appears to be very efficient. As an example, it took about 0.02s on a Silicon Graphics (Indy 100 MHZ Processor, 64 Mb RAM) to determinize the transducer of Figure 18.1' Determinization makes the use of lattices much faster. Since at any state there exists at most one transition labeled with the word considered, finding the weight associated with a sentence does not depend on the size of the lattice. The time and space complexity of such an operation is simply linear in the size of the sentence. When dealing with large tasks, most speech recognition systems use a rescoring method (Figure 21). This consists of first using a simple acoustic and grammar model to produce a word lattice, and then to reevaluate this word lattice with a more sophisticated model. The size of the word lattice is then a critical parameter in the time and space efficiency of the system. The determinization and minimization algorithms we presented allow the size of such word lattices to be considerably reduced, as seen in the examples. We experimented with both determinization and minimization algorithms in the ATIS task. Table 1 illustrates these results. It shows these algorithms to be very effective in reducing the redundancy of speech networks in this task. The reduction is also illustrated by an example in the ATIS task. The number of paths of the word lattice before determinization was larger than that of the largest integer representable with 32 bit machines. We also experimented with the minimization algorithm by applying it to several word lattices obtained in the 60,000-word ARPA North American Business News task (NAB). These lattices were already determinized. Table 2 shows the average reduction factors we obtained when using the minimization algorithms with several subsequential lattices obtained for utterances of the NAB task. The reduction factors help to measure the gain of minimization alone, since the lattices are already subsequential. The numbers in example 2, an example of reduction we obtained, correspond to a typical case. An important characteristic of the determinization algorithm is that it can be used on-the-fly. Indeed, the determinization algorithm is such that given a subset representing a state of the resulting transducer, the definition of the transitions leaving that state depends only on that state or, equivalently, on the states of that subset, and on the transducer to determinize. In particular, the definition and construction of these transitions do not depend directly on the previous subsets constructed. We have produced an implementation of the determinization that allows one both to completely expand the result or to expand it on demand. Arcs leaving a state of Mohri Transducers in Language and Speech the determinized transducer are expanded only if necessary This characteristic of the implementation is important. It can then be used, for instance, at any step in an onthe-fly cascade of composition of transducers in speech recognition to expand only the necessary part of a lattice or transducer (Pereira and Riley 1996; Mohri, Pereira, and Riley 1996). One of the essential implications of the implementation is that it contributes to saving space during the search stage. It is also very useful in speeding up the n-best decoder in speech recognition.' The determinization and minimization algorithms for string-to-weight transducers seem to have other applications in speech processing. Many new experiments can be done using these algorithms at different stages of speech recognition, which might lead to the reshaping of some of the methods used in this field and create a renewed interest in the theory of automata and transducers.
5.. We have briefly presented the theoretical bases, algorithmic tools, and practical use of a set of devices that seem to fit the complexity of language and provide efficiency in space and time. From the theoretical point of view, the understanding of these objects is crucial. It helps to describe the possibilities they offer and to guide algorithmic choices. Many new theoretical issues arise when more precision is sought. The notion of determinization can be generalized to that of E-determinization for instance (Salomaa and Soittola 1978, chapter 3, exercise) requiring more general algorithms. It can also be extended to local determinization: determinization at only those states of a transducer that admit a predefined property, such as that of having a large number of outgoing transitions. An important advantage of local determinization is that it can be applied to any transducer without restriction. Furthermore, local determinization also admits an on-the-fly implementation. New characterizations of rational functions shed new light on some aspects of the theory of finite-state transducers (Reutenauer and Schiitzenberger 1995). We have also offered a generalization of the operations we use based on the notions of semiring and power series, which help to simplify problems and algorithms used in various cases. In particular, the string semirirtg that we introduced makes it conceptually easier to describe many algorithms and properties. Subsequential transducers admit very efficient algorithms. The determinization and minimization algorithms in the case of string-to-weight transducers presented here complete a large series of algorithms that have been shown to give remarkable results in natural language processing. Sequential machines lead to useful algorithms in many other areas of computational linguistics. In particular, subsequential power series allow for efficient results in indexation of natural language texts (Crochemore 1986; Mohri 1996b). We briefly illustrated the application of these algorithms to speech recognition. More precision in acoustic modeling, finer language models, large lexicon grammars, and a larger vocabulary will lead, in the near future, to networks of much larger sizes in speech recognition. The determinization and minimization algorithms might help to limit the size of these networks while maintaining their time efficiency. These algorithms can also be used in text-to-speech synthesis. In fact, the same operations of composition of transducers (Sproat 1995) and perhaps more important size issues can be found in this field. Subsequential power series S nonbisubsequential.
Appendix. The determinization algorithm for power series can also be used to minimize transducers in many cases. Let us first consider the case of automata. Brzozowski (1962) showed that determinization can be used to minimize automata. This nice result has also been proved more recently in elegant papers by Bauer (1988) and Urbanek (1989). These authors refine the method to obtain better complexities.19 Theorem 16 (Brzozowski 1962) Let A be a nondeterministic automaton. Then the automaton A' = (Q', i',F',E,6') obtained by reversing A, applying determinization, rereversing the obtained automaton and determiruizing it is the minimal deterministic automaton equivalent to A. We generalize this theorem to the case of string-to-weight transducers. We say that a rational power series S is bisubsequential when S is subsequential and the power series SR = EwEE. (5, wR)w is also subsequential.' Not all subsequential transducers are bisubsequential. Figure 22 shows a transducer representing a power series S that is not bisubsequential. S is such that: The transducer of Figure 22 is subsequential so S is subsequential. But the reverse SR is not, because it does not have bounded variation. Indeed, since: We have: Vn E AT , l(SR , a&quot; b) — (SR , an c)I = n +1 Mohri Transducers in Language and Speech A characterization similar to that of string-to-string transducers (Choffrut 1978) is possible for bisubsequential power series defined on the tropical semiring. In particular, the theorem of the previous sections shows that S is bisubsequential if S and SR have bounded variation. We similarly define bideterminizable transducers as the transducers T defined on the tropical semiring admitting two applications of determinization, as follows: In this definition, we assume that the reverse operation is performed simply by reversing the direction of the transitions and exchanging initial and final states. Given this definition, we can present the extension of the theorem of Brzozowski (1962) to bideterminizable transducers.21 Theorem 17 Let T be a bideterminizable transducer defined on the tropical semiring. Then the transducer det(klet(TR)r) obtained by reversing T, applying determinization, rereversing the obtained transducer and determinizing it is a minimal subsequential transducer equivalent to T. Proof We denote by: The double reverse and determinization algorithms clearly do not change the function that T realizes. So T' is a subsequential transducer equivalent to T. We only need to prove that T' is minimal. This is equivalent to showing that T&quot; is minimal, since T' and T&quot; have the same number of states. Ti is the result of a determinization, hence it is a trim subsequential transducer. We show that T' det(n) is minimal if Ti is a trim subsequential transducer. Notice that the theorem does not require that T be subsequential. Let Si and 52 be two states of T&quot; equivalent in the sense of automata. We prove that Si = Sz, namely that no two distinct states of T&quot; can be merged. This will prove that T&quot; is minimal. Since pushing only affects the output labels, T' and T&quot; have the same set of states: Q' = Q&quot;. Hence Si and S2 are also states of T'. The states of T' can be viewed as weighted subsets whose state elements belong to T,, because T' is obtained by determinization of T. Let (q, c) E Qi X R. be a pair of the subset Si. Since Ti is trim there exists w E E* such that Si (ii, w) = q, so Si(Si, w) E F'. Since Si and S2 are equivalent, we also have: 21 The theorem also holds in the case of string-to-string bideterminizable transducers. We give the proof in the more complex case of string-to-weight transducers. Minimal transducer 04 obtained by reversing 03 and applying determinization. 6'(S2, 7.1)) E F'. Since T1 is subsequential, there exists only one state of Tf admitting a path labeled with w to ii; that state is q. Thus, q E S2. Therefore any state q member of a pair of Si is also member of a pair of S2. By symmetry the reverse is also true. Thus exactly the same states are members of the pairs of Si and S2. There exists k > 0 such that: We prove that weights are also the same in Si and 52. Let Hy, (0 > j > k), be the set of strings labeling the paths from i3 to qi in T1. cffi(ii, w) is the weight output corresponding to a string w E R. Consider the accumulated weights c11, 1 < i < 2, 0 <j < k, in determinization of T. Each cl; for instance corresponds to the weight not yet output in the paths reaching Si. It needs to be added to the weights of any path from qj E S1 to a final state in rev(Ti). In other terms, the determinization algorithm will assign the weight c + w) + Ai to a path labeled with wR reaching a final state of T' from Si. T&quot; is obtained by pushing from T'. Therefore the weight of such We noticed in the proof of the determinization theorem that the minimum weight of the pairs of any subset is 0. Therefore: Vj E [O. k], C11 = C21 and S2 =- S1. This ends the proof of the theorem. 0 Figures 23-25 illustrate the minimization of string-to-weight transducers using the determinization algorithm. The transducer 02 of Figure 23 is obtained from that of Figure 15, IA, by reversing it. The application of determinization to 02 results in 03 (Figure 24). Notice that since 01 is subsequential, according to the theorem the transducer 03 is minimal too. 03 is then reversed and determinized (Figure 25). The resulting transducer 04 is minimal and equivalent to 01. Comparing the transducer 04 to the transducer of Figure 17, Si, we note that both are minimal and realize the same function. Si provides output weights as soon as possible; it can be obtained from 04 by pushing.
Acknowledgments. I thank Michael Riley, and also CL reviewers, for their comments on earlier versions of this paper, Fernando Pereira and Michael Riley for discussions, Andrej Ljolje for providing the word lattices cited herein, Phil Terscaphen for useful advice, and Dominique Perrin for his help in finding references relating to the minimization of automata by determinization.