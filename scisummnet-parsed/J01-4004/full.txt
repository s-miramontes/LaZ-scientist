DSO National Laboratories. In this paper, we present a learning approach to coreference resolution of noun phrases in unrestricted text. The approach learns from a small, annotated corpus and the task includes resolving not just a certain type of noun phrase (e.g., pronouns) but rather general noun phrases. It also does not restrict the entity types of the noun phrases; that is, coreference is assigned whether they are of &quot;organization,&quot; &quot;person,&quot; or other types. We evaluate our approach on common data sets (namely, the MUC-6 and MUC-7 coreference corpora) and obtain encouraging results, indicating that on the general noun phrase coreference task, the learning approach holds promise and achieves accuracy comparable to that of nonlearning approaches. Our system is the first learning-based system that offers performance comparable to that of state-of-the-art nonlearning systems on these data sets.
1.. Coreference resolution is the process of determining whether two expressions in natural language refer to the same entity in the world. It is an important subtask in natural language processing systems. In particular, information extraction (IE) systems like those built in the DARPA Message Understanding Conferences (Chinchor 1998; Sundheim 1995) have revealed that coreference resolution is such a critical component of IE systems that a separate coreference subtask has been defined and evaluated since MUC-6 (MUC-6 1995). In this paper, we focus on the task of determining coreference relations as defined in MUC-6 (MUC-6 1995) and MUC-7 (MUC-7 1997). Specifically, a coreference relation denotes an identity of reference and holds between two textual elements known as markables, which can be definite noun phrases, demonstrative noun phrases, proper names, appositives, sub—noun phrases that act as modifiers, pronouns, and so on. Thus, our coreference task resolves general noun phrases and is not restricted to a certain type of noun phrase such as pronouns. Also, we do not place any restriction on the possible candidate markables; that is, all markables, whether they are &quot;organization,&quot; &quot;person,&quot; or other entity types, are considered. The ability to link coreferring noun phrases both within and across sentences is critical to discourse analysis and language understanding in general. System architecture of natural language processing pipeline.
2.. We adopt a corpus-based, machine learning approach to noun phrase coreference resolution. This approach requires a relatively small corpus of training documents that have been annotated with coreference chains of noun phrases. All possible markables in a training document are determined by a pipeline of language-processing modules, and training examples in the form of feature vectors are generated for appropriate pairs of markables. These training examples are then given to a learning algorithm to build a classifier. To determine the coreference chains in a new document, all markables are determined and potential pairs of coreferring markables are presented to the classifier, which decides whether the two markables actually corefer. We give the details of these steps in the following subsections. A prerequisite for coreference resolution is to obtain most, if not all, of the possible markables in a raw input text. To determine the markables, a pipeline of natural language processing (NLP) modules is used, as shown in Figure 1. They consist of tokenization, sentence segmentation, morphological processing, part-of-speech tagging, noun phrase identification, named entity recognition, nested noun phrase extraction, and semantic class determination. As far as coreference resolution is concerned, the goal of these NLP modules is to determine the boundary of the markables, and to provide the necessary information about each markable for subsequent generation of features in the training examples. Our part-of-speech tagger is a standard statistical tagger based on the Hidden Markov Model (HMM) (Church 1988). Similarly, we built a statistical HMM-based noun phrase identification module that determines the noun phrase boundaries solely based on the part-of-speech tags assigned to the words in a sentence. We also implemented a module that recognizes MUC-style named entities, that is, organization, person, location, date, time, money, and percent. Our named entity recognition module uses the HMM approach of Bikel, Schwartz, and Weischedel (1999), which learns from a tagged corpus of named entities. That is, our part-of-speech tagger, noun phrase identification module, and named entity recognition module are all based on HMMs and learn from corpora tagged with parts of speech, noun phrases, and named entities, respectively. Next, both the noun phrases determined by the noun phrase identification module and the named entities are merged in such a way that if the noun phrase overlaps with a named entity, the noun phrase boundaries will be adjusted to subsume the named entity. The nested noun phrase extraction module subsequently accepts the noun phrases and determines the nested phrases for each noun phrase. The nested noun phrases are divided into two groups: Finally, the markables needed for coreference resolution are the union of the noun phrases, named entities, and nested noun phrases found. For markables without any named entity type, semantic class is determined by the semantic class determination module. More details regarding this module are given in the description of the semantic class agreement feature. To achieve acceptable recall for coreference resolution, it is most critical that the eligible candidates for coreference be identified correctly in the first place. In order to test our system's effectiveness in determining the markables, we attempted to match the markables generated by our system against those appearing in the coreference chains annotated in 100 SGML documents, a subset of the training documents available in MUC-6. We found that our system is able to correctly identify about 85% of the noun phrases appearing in coreference chains in the 100 annotated SGML documents. Most of the unmatched noun phrases are of the following types: To build a learning-based coreference engine, we need to devise a set of features that is useful in determining whether two markables corefer or not. In addition, these features must be generic enough to be used across different domains. Since the MUC-6 and MUC-7 tasks define coreference guidelines for all types of noun phrases and different types of noun phrases behave differently in terms of how they corefer, our features must be able to handle this and give different coreference decisions based on different types of noun phrases. In general, there must be some features that indicate the type of a noun phrase. Altogether, we have five features that indicate whether the markables are definite noun phrases, demonstrative noun phrases, pronouns, or proper names. There are many important knowledge sources useful for coreference. We wanted to use those that are not too difficult to compute. One important factor is the distance between the two markables. McEnery, Tanaka, and Botley (1997) have done a study on how distance affects coreference, particularly for pronouns. One of their conclusions is that the antecedents of pronouns do exhibit clear quantitative patterns of distribution. The distance feature has different effects on different noun phrases. For proper names, locality of the antecedents may not be so important. We include the distance feature so that the learning algorithm can best decide the distribution for different classes of noun phrases. There are other features that are related to the gender, number, and semantic class of the two markables. Such knowledge sources are commonly used for the task of determining coreference. Our feature vector consists of a total of 12 features described below, and is derived based on two extracted markables, i and j, where i is the potential antecedent and j is the anaphor. Information needed to derive the feature vectors is provided by the pipeline of language-processing modules prior to the coreference engine. false. If the string of i matches the string of j, return true; else return false. We first remove articles (a, an, the) and demonstrative pronouns (this, these, that, those) from the strings before performing the string comparison. Therefore, the license matches this license, that computer matches computer. 5. Definite Noun Phrase Feature (DEF_NP): Its possible values are true or false. In our definition, a definite noun phrase is a noun phrase that starts with the word the. For example, the car is a definite noun phrase. If j is a definite noun phrase, return true; else return false. true or false. A demonstrative noun phrase is one that starts with the word this, that, these, or those. If] is a demonstrative noun phrase, then return true; else return false. 7. Number Agreement Feature (NUMBER): Its possible values are true or false. If i and j agree in number (i.e., they are both singular or both plural), the value is true; otherwise false. Pronouns such as they and them are plural, while it, him, and so on, are singular. The morphological root of a noun is used to determine whether it is singular or plural if the noun is not a pronoun.
8.. are true, false, or unknown. In our system, we defined the following semantic classes: &quot;female,&quot; &quot;male,&quot; &quot;person,&quot; &quot;organization,&quot; &quot;location,&quot; &quot;date,&quot; &quot;time,&quot; &quot;money,&quot; &quot;percent,&quot; and &quot;object.&quot; These semantic classes are arranged in a simple ISA hierarchy. Each of the &quot;female&quot; and &quot;male&quot; semantic classes is a subclass of the semantic class &quot;person,&quot; while each of the semantic classes &quot;organization,&quot; &quot;location,&quot; &quot;date,&quot; &quot;time,&quot; &quot;money,&quot; and &quot;percent&quot; is a subclass of the semantic class &quot;object.&quot; Each of these defined semantic classes is then mapped to a WordNet synset (Miller 1990). For example, &quot;male&quot; is mapped to the second sense of the noun male in WordNet, &quot;location&quot; is mapped to the first sense of the noun location, and so on. The semantic class determination module assumes that the semantic class for every markable extracted is the first sense of the head noun of the markable. Since WordNet orders the senses of a noun by their frequency, this is equivalent to choosing the most frequent sense as the semantic class for each noun. If the selected semantic class of a markable is a subclass of one of our defined semantic classes C, then the semantic class of the markable is C; else its semantic class is &quot;unknown.&quot; The semantic classes of markables i and j are in agreement if one is the parent of the other (e.g., chairman with semantic class &quot;person&quot; and Mr. Lim with semantic class &quot;male&quot;), or they are the same (e.g., Mr. Lim and he, both of semantic class &quot;male&quot;). The value returned for such cases is true. If the semantic classes of i and j are not the same (e.g., IBM with semantic class &quot;organization&quot; and Mr. Lim with semantic class &quot;male&quot;), return false. If either semantic class is &quot;unknown,&quot; then the head noun strings of both markables are compared. If they are the same, return true; else return unknown. on the named entity type. For i and j that are dates (e.g., 01-08 and Jan. 8), by using string comparison, the day, month, and year values are extracted and compared. If they match, then j is an alias of i. For i and j that are &quot;person,&quot; such as Mr. Simpson and Bent Simpson, the last words of the noun phrases are compared to determine whether one is an alias of the other. For organization names, the alias function also checks for acronym match such as IBM and International Business Machines Corp. In this case, the longer string is chosen to be the one that is converted into the acronym form. The first step is to remove all postmodifiers such as Corp. and Ltd. Then, the acronym function considers each word in turn, and if the first letter is capitalized, it is used to form the acronym. Two variations of the acronyms are produced: one with a period after each letter, and one without. 12. Appositive Feature (APPOSITIVE): Its possible values are true or false. If j is in apposition to i, return true; else return false. For example, the markable the chairman of Microsoft Corp. is in apposition to Bill Gates in the sentence Bill Gates, the chairman of Microsoft Corp., . . . . Our system determines whether j is a possible appositive construct by first checking for the existence of verbs and proper punctuation. Like the above example, most appositives do not have any verb; and an appositive is separated by a comma from the most immediate antecedent, i, to which it refers. Further, at least one of i and j must be a proper name. The MUC-6 and MUC-7 coreference task definitions are slightly different. In MUC-6, j needs to be a definite noun phrase to be an appositive, while both indefinite and definite noun phrases are acceptable in MUC-7. As an example, Table 1 shows the feature vector associated with the antecedent i, Frank Newman, and the anaphor j, vice chairman, in the following sentence: Feature vector of the markable pair (i = Frank Newman, j = vice chairman). Because of capitalization, markables in the headlines of MUC-6 and MUC-7 documents are always considered proper names even though some are not. Our system solves this inaccuracy by first preprocessing a headline to correct the capitalization before passing it into the pipeline of NLP modules. Only those markables in the headline that appear in the text body as proper names have their capitalization changed to match those found in the text body. All other headline markables are changed to lowercase. Consider a coreference chain Al - A2 - A3 - A4 found in an annotated training document. Only pairs of noun phrases in the chain that are immediately adjacent (i.e., Al A2, A2 - A3, and A3 - A4) are used to generate the positive training examples. The first noun phrase in a pair is always considered the antecedent, while the second is the anaphor. On the other hand, negative training examples are extracted as follows. Between the two members of each antecedent-anaphor pair, there are other markables extracted by our language-processing modules that either are not found in any coreference chain or appear in other chains. Each of them is then paired with the anaphor to form a negative example. For example, if markables a, b, and B1 appear between Al and A2, then the negative examples are a - A2, b - A2, and B1 - A2. Note that a and b do not appear in any coreference chain, while B1 appears in another coreference chain. For an annotated noun phrase in a coreference chain in a training document, the same noun phrase must be identified as a markable by our pipeline of languageprocessing modules before this noun phrase can be used to form a feature vector for use as a training example. This is because the information necessary to derive a feature vector, such as semantic class and gender, is computed by the languageprocessing modules. If an annotated noun phrase is not identified as a markable, it will not contribute any training example. To see more clearly how training examples are generated, consider the following four sentences: Each sentence is shown twice with different noun phrase boundaries. Sentences labeled (1) are obtained directly from part of the training document. The letters in the subscripts uniquely identify the coreference chains, while the numbers identify the noun phrases. Noun phrases in sentences labeled (2) are extracted by our languageprocessing modules and are also uniquely identified by numeric subscripts. Let's consider chain e, which is about the union. There are three noun phrases that corefer, and our system managed to extract the boundaries that correspond to all of them: (union)7 matches with (union)ei, (union)13 with (union)e2, and (its unions)22 with (its unions)e3. There are two positive training examples formed by ((union)13, (its unions)22) and ((union)7, (union)13). Noun phrases between (union)7 and (union)13 that do not corefer with (union)13 are used to form the negative examples. The negative examples are ((the carrier)9, (union)13), ((wage)io, (union)13), ((selective wage reductions)n, (union)13), and ((Feb. 3)12, (union)13). Negative examples can also be found similarly between ((union)13, (its unions)22). As another example, neither noun phrase in chain d, (Pay-Cut)di and (wage reductions)d2, matches with any machine-extracted noun phrase boundaries. In this case, no positive or negative example is formed for noun phrases in chain d. The next step is to use a machine learning algorithm to learn a classifier based on the feature vectors generated from the training documents. The learning algorithm used in our coreference engine is C5, which is an updated version of C4.5 (Quinlan 1993). C5 is a commonly used decision tree learning algorithm and thus it may be considered as a baseline method against which other learning algorithms can be compared. Before determining the coreference chains for a test document, all possible markables need to be extracted from the document. Every markable is a possible anaphor, and every markable before the anaphor in document order is a possible antecedent of the anaphor, except when the anaphor is nested. If the anaphor is a child or nested markable, then its possible antecedents must not be any markable with the same root markable as the current anaphor. However, the possible antecedents can be other root markables and their children that are before the anaphor in document order. For example, consider the two root markables, Mr. Tom's daughter and His daughter's eyes, appearing in that order in a test document. The possible antecedents of His cannot be His daughter or His daughter's eyes, but can be Mr. Tom or Mr. Tom's daughter. . The coreference resolution algorithm considers every markable j starting from the second markable in the document to be a potential candidate as an anaphor. For each j, the algorithm considers every markable i before j as a potential antecedent. For each pair i and j, a feature vector is generated and given to the decision tree classifier. A coreferring antecedent is found if the classifier returns true. The algorithm starts from the immediately preceding markable and proceeds backward in the reverse order of the markables in the document until there is no remaining markable to test or an antecedent is found. As an example, consider the following text with markables already detected by the NLP modules: (2) (Ms. Washington)73's candidacy is being championed by (several powerful lawmakers)74 including ((her)76 boss)75, (Chairman John Dinge11)77 (D., (Mich.)78) of (the House Energy and Commerce Committee)79. (She)80 currently is (a counse1)81 to (the committee)82. (Ms. Washington)83 and (Mr. Dinge11)84 have been considered (allies)85 of (the (securities)87 exchanges)86, while (banks)88 and ((futures)90 exchanges)89 have often fought with (them)91. We will consider how the boldfaced chains are detected. Table 2 shows the pairs of markables tested for coreference to form the chain for Ms. Washington-her-She-Ms. Washington. When the system considers the anaphor, (her)76, all preceding phrases, except (her boss)75, are tested to see whether they corefer with it. (her boss)75 is not tested because (her)76 is its nested noun phrase. Finally, the decision tree determines that the noun phrase (Ms. Washington)73 corefers with (her)76. In Table 2, we only show the system considering the three anaphors (her)76, (She)80, and (Ms. Washington)83, in that order. We use the same method to generate coreference chains for both MUC-6 and MUC7, except for the following. For MUC-7, because of slight changes in the coreference task definition, we include a filtering module to remove certain coreference chains. The task definition states that a coreference chain must contain at least one element that is a head noun or a name; that is, a chain containing only prenominal modifiers is removed by the filtering module.
3.. In order to evaluate the performance of our learning approach to coreference resolution on common data sets, we utilized the annotated corpora and scoring programs from MUC-6 and MUC-7, which assembled a set of newswire documents annotated with coreference chains. Although we did not participate in either MUC-6 or MUC-7, we were able to obtain the training and test corpora for both years from the MUC organizers for research purposes.' To our knowledge, these are the only publicly available annotated corpora for coreference resolution. For MUC-6, 30 dry-run documents annotated with coreference information were used as the training documents for our coreference engine. There are also 30 annotated training documents from MUC-7. The total size of the 30 training documents is close to 12,400 words for MUC-6 and 19,000 words for MUC-7. There are altogether 20,910 (48,872) training examples used for MUC-6 (MUC-7), of which only 6.5% (4.4%) are positive examples in MUC-6 (MUC-7).2 After training a separate classifier for each year, we tested the performance of each classifier on its corresponding test corpus. For MUC-6, the C5 pruning confidence is set at 20% and the minimum number of instances per leaf node is set at 5. For MUC-7, the pruning confidence is 60% and the minimum number of instances is 2. The parameters are determined by performing 10-fold cross-validation on the whole training set for each MUC year. The possible pruning confidence values that we tried are 10%, 20%, 40%, 60%, 80%, and 100%, and for minimum instances, we tried 2, 5, 10, 15, and 20. Thus, a total of 30 (6 x 5) cross-validation runs were executed. One advantage of using a decision tree learning algorithm is that the resulting decision tree classifier can be interpreted by humans. The decision tree generated for MUC-6, shown in Figure 2, seems to encapsulate a reasonable rule of thumb that matches our intuitive linguistic notion of when two noun phrases can corefer. It is also interesting to note that only 8 out of the 12 available features in the training examples are actually used in the final decision tree built. MUC-6 has a standard set of 30 test documents, which is used by all systems that participated in the evaluation. Similarly, MUC-7 has a test corpus of 20 documents. We compared our system's MUC-6 and MUC-7 performance with that of the systems that took part in MUC-6 and MUC-7, respectively. When the coreference engine is given new test documents, its output is in the form of SGML files with the coreference chains properly annotated according to the guidelines.3 We then used the scoring programs The decision tree classifier learned for MUC-6. for the respective years to generate the recall and precision scores for our coreference engine. Our coreference engine achieves a recall of 58.6% and a precision of 67.3%, yielding a balanced F-measure of 62.6% for MUC-6. For MUC-7, the recall is 56.1%, the precision is 65.5%, and the balanced F-measure is 60.4%.4 We plotted the scores of our coreference engine (square-shaped) against the official test scores of the other systems (crossshaped) in Figure 3 and Figure 4. We also plotted the learning curves of our coreference engine in Figure 5 and Figure 6, showing its accuracy averaged over three random trials when trained on 1, 2, 3, 4, 5, 10, 15, 20, 25, and 30 training documents. The learning curves indicate that our coreference engine achieves its peak performance with about 25 training documents, or about 11,000 to 17,000 words of training documents. This number of training documents would generate tens of thousands of training examples, sufficient for the decision tree learning algorithm to learn a good classifier. At higher numbers of training documents, our system seems to start overfitting the training data. For example, on MUC-7 data, training on the full set of 30 training documents results in a more complex decision tree. Our system's scores are in the upper region of the MUC-6 and MUC-7 systems. We performed a simple one-tailed, paired sample t-test at significance level p = 0.05 to determine whether the difference between our system's F-measure score and each of the other systems' F-measure score on the test documents is statistically significant.5 We found that at the 95% significance level (p = 0.05), our system performed better than three MUC-6 systems, and as well as the rest of the MUC-6 systems. Using the Coreference scores of MUC-7 systems and our system. same significance level, our system performed better than four MUC-7 systems, and as well as the rest of the MUC-7 systems. Our result is encouraging since it indicates that a learning approach using relatively shallow features can achieve scores comparable to those of systems built using nonlearning approaches. It should be noted that the accuracy of our coreference resolution engine depends to a large extent on the performance of the NLP modules that are executed before the coreference engine. Our current learning-based, HMM named entity recognition module is trained on 318 documents (a disjoint set from both the MUC-6 and MUC-7 test documents) tagged with named entities, and its score on the MUC-6 named entity task for the 30 formal test documents is only 88.9%, which is not considered very high by MUC-6 standards. For example, our named entity recognizer could not identify the two named entities USAir and Piedmont in the expression USAir and Piedmont but instead treat them as one single named entity. Our part-of-speech tagger achieves 96% accuracy, while the accuracy of noun phrase identification is above 90%.
4.. One factor that affects the performance of a machine learning approach is the set of features used. It is interesting to find out how useful each of our 12 features is in the MUC-6 and MUC-7 coreference tasks. One way to do this is to train and test using just one feature at a time. Table 3 and Table 4 show the results of the experiment. For both MUC-6 and MUC-7, the 3 features that give nonzero recall and precision are ALIAS, STR_MATCH, and APPOSITIVE. The 12 features can be divided into unary and binary features. The unary features are I_PRONOUN, J_PRONOUN, DEF_NP, and DEM_NP, while the rest are binary in nature. All the unary features score an F-measure of 0. The binary features with 0 F-measure are DIST, PROPER_NAME, GENDER, SEMCLASS, and NUMBER. The ALIAS, APPOSITIVE, and STR_MATCH features give nonzero F-measure. All these features give rather high precision scores (> 80% for ALIAS, > 65% for STR_MATCH, and > 57% for APPOSITIVE). Since these features are highly informative, we were curious to see how much they contribute to our MUC-6 and MUC-7 results of 62.6% and 60.4%, respectively. Systems ALIAS_STR and ALIAS_STR_APPOS in Table 3 and Table 4 show the results of the experiment. In terms of absolute Fmeasure, the difference between using these three features and using all features is 2.3% for MUC-6 and 1% for MUC-7; in other words, the other nine features contribute just 2.3% and 1% more for each of the MUC years. These nine features will be the first ones to be considered for pruning away by the C5 algorithm. For example, four features, namely, SEMCLASS, PROPER_NAME, DEF_NP, and DEM_NP, are not used in the MUC-6 tree shown in Figure 2. Figure 7 shows the distribution of the test cases over the five positive leaf nodes of the MUC-6 tree. For example, about 66.3% of all Distribution of test examples from the 30 MUC-6 test documents for positive leaf nodes of the MUC-6 tree. the test examples that are classified positive go to the &quot;If STR_MATCH&quot; branch of the tree. Other baseline systems that are used are ONE_CHAIN, ONE_WRD, and HD_WRD (Cardie and Wagstaff 1999). For ONE_CHAIN, all markables formed one chain. In ONE_WRD, markables corefer if there is at least one common word. In HD_WRD, markables corefer if their head words are the same. The purpose of ONE-CHAIN is to determine the maximum recall our system is capable of. The recall level here indirectly measures how effective the noun phrase identification module is. Both ONE_WRD and HD_WRD are less stringent variations of STR_MATCH. The performance of ONE_WRD is the worst. HD_WRD offers better recall compared to STR_MATCH, but poorer precision. However, its F-measure is comparable to that of STR_MATCH. The score of the coreference system at the University of Massachusetts (RESOLVE), which uses C4.5 for coreference resolution, is shown in Table 3. RESOLVE is shown because among the MUC-6 systems, it is the only machine learning—based system that we can directly compare to. The other MUC-6 systems were not based on a learning approach. Also, none of the systems in MUC-7 adopted a learning approach to coreference resolution (Chinchor 1998). RESOLVE's score is not high compared to scores attained by the rest of the MUC6 systems. In particular, the system's recall is relatively low. Our system's score is higher than that of RESOLVE, and the difference is statistically significant. The RESOLVE system is described in three papers: McCarthy and Lehnert (1995), Fisher et al. (1995), and McCarthy (1996). As explained in McCarthy (1996), the reason for this low recall is that RESOLVE takes only the &quot;relevant entities&quot; and &quot;relevant references&quot; as input, where the relevant entities and relevant references are restricted to &quot;person&quot; and &quot;organization.&quot; In addition, because of limitations of the noun phrase detection module, nested phrases are not extracted and therefore do not take part in coreference. Nested phrases can include prenominal modifiers, possessive pronouns, and so forth. Therefore, the number of candidate markables to be used for coreference is small. On the other hand, the markables extracted by our system include nested noun phrases, MUC-style named entity types (money, percent, date, etc. ), and other types not defined by MUC. These markables will take part in coreference. About 3,600 toplevel markables are extracted from the 30 MUC-6 test documents by our system. As detected by our NLP modules, only about 35% of these 3,600 phrases are &quot;person&quot; and &quot;organization&quot; entities and references. Concentrating on just these types has thus affected the overall recall of the RESOLVE system. RESOLVE's way of generating training examples also differs from our system's: instances are created for all possible pairings of &quot;relevant entities&quot; and &quot;relevant references,&quot; instead of our system's method of stopping at the first coreferential noun phrase when traversing back from the anaphor under consideration. We implemented RESOLVE's way of generating training examples, and the results (DSO-TRG) are reported in Table 3 and Table 4. For MUC-7, there is no drop in F-measure; for MUC-6, the F-measure dropped slightly. RESOLVE makes use of 39 features, considerably more than our system's 12 features. RESOLVE's feature set includes the two highly informative features, ALIAS and STR_MATCH. RESOLVE does not use the APPOSITIVE feature.
5.. In order to determine the major classes of errors made by our system, we randomly chose five test documents from MUC-6 and determined the coreference links that were either missing (false negatives) or spurious (false positives) in these sample documents. Missing links result in recall errors; spurious links result in precision errors. Breakdowns of the number of spurious and missing links are shown in Table 5 and Table 6, respectively. The following two subsections describe the errors in more detail. This section describes the five major types of errors summarized in Table 5 in more detail. 5.1.1 Prenominal Modifier String Match. This class of errors occurs when some strings of the prenominal modifiers of two markables match by surface string comparison and thus, by the C5 decision tree in Figure 2, the markables are treated as coreferring. However, the entire markable actually does not corefer. The nested noun phrase extraction module is responsible for obtaining the possible prenominal modifiers from a noun phrase. In (3), the noun phrase extraction module mistakenly extracted (vice)1 and (vice)2, which are not prenominal modifiers. Because of string match, (vice)1 and (vice)2 incorrectly corefer. In (4), (undersecretary)2 was correctly extracted as a prenominal modifier, but incorrectly corefers with (undersecretary)i by string match. Council on Foreign Relations, is expected to be named (undersecretary)1 for political affairs.... Former Sen. Tim Wirth is expected to get a newly created (undersecretary)2 post for global affairs, which would include refugees, drugs and environmental issues. when the surface strings of two markables match and thus, by the C5 decision tree in Figure 2, they are treated as coreferring. However, they actually refer to different entities and should not corefer. In (5), (the committee)i actually refers to the entity the House Energy and Commerce Committee, and (the committee)2 refers to the Senate Finance Committee; therefore, they should not corefer. In (6), the two instances of chief executive officer refer to two different persons, namely, Allan Laufgraben and Milton Petrie, and, again, should not corefer. made by the noun phrase identification module. In (7), May and June are incorrectly grouped together by the noun phrase identification module as one noun phrase, that is, May, June. This markable then incorrectly causes the APPOSITIVE feature to be true, which results in classifying the pair as coreferential. In fact, (the first week of July)2 should not be in apposition to (May, June)i. However, we classified this error as a noun phrase identification error because it is the first module that causes the error. In (8), the noun phrase module extracted Metaphor Inc. instead of Metaphor Inc. unit. This causes (it)2 to refer to Metaphor Inc. instead of Metaphor Inc. unit. is incorrectly treated as being in apposition to the antecedent and therefore causes the noun phrases to corefer. The precision scores obtained when using the APPOSITIVE feature alone are shown in Table 3 and Table 4, which suggest that the module can be improved further. Examples where apposition determination is incorrect are shown in Matthew McHugh (D., (N.Y.)i) and (environmental activist)2 and transition official Gus Speth for the director of the Agency for International Development. (10) Metaphor, a software subsidiary that IBM purchased in 1991, also named (Chris Grejtak)2, (43 years old)2, currently a senior vice president, president and chief executive officer. 5.1.5 Errors in Alias Determination. This class of errors occurs when the anaphor is incorrectly treated as an alias of the antecedent, thus causing the noun phrase pair to corefer. In (11), the two phrases (House)i and (the House Energy and Commerce Committee)2 corefer because the ALIAS feature is incorrectly determined to be true. (11) Consuela Washington, a longtime (House)i staffer and an expert in securities laws, is a leading candidate to be chairwoman of the Securities and Exchange Commission in the Clinton administration.... Ms. Washington's candidacy is being championed by several powerful lawmakers including her boss, Chairman John Dingell (D., Mich.) of (the House Energy and Commerce Committee)2. This subsection describes the six major classes of errors summarized in Table 6 in more detail. 5.2.1 Inadequacy of Current Surface Features. This class of errors is due to the inadequacy of the current surface features because they do not have information about other words (such as the connecting conjunctions, prepositions, or verbs) and other knowledge sources that may provide important clues for coreference. As a result, the set of shallow features we used is unable to correctly classify the noun phrases in the examples below as coreferring. Example (12) illustrates why resolving (them)2 is difficult. (allies)i, securities exchanges, banks, and futures exchanges are all possible antecedents of (them)2, and the feature set must include more information to be able to pick the correct one. The conjunction and in (13) and was named in (16) are important cues to determine coreference. In addition, it may also be possible to capture noun phrases in predicate constructions like (17), where (Mr. Gleason)i is the subject and (president)2 is the object. tion 5.1.3. The noun phrase identification module may extract noun phrases that do not match the phrases in the coreference chain, therefore causing missing links and recall error. 5.2.3 Errors in Semantic Class Determination. These errors are caused by the wrong assignment of semantic classes to words. For example, (Metaphor)i should be assigned &quot;organization&quot; but it is assigned &quot;unknown&quot; in (18), and (second-quarter)2 should be assigned &quot;date&quot; instead of &quot;unknown&quot; in (19). However, correcting these classes will still not cause the noun phrases in the examples to corefer. This is because the values of the SEMCLASS feature in the training examples are extremely noisy, a situation caused largely by our semantic class determination module. In many of the negative training examples, although the noun phrases are assigned the same semantic classes, these assignments do not seem to be correct. Some examples are (four-year, NBC), (The union, Ford Motor Co.), and (base-wage, job-security). A better algorithm for assigning semantic classes and a more refined semantic class hierarchy are needed. (21) Separately, MGM said it completed a previously announced financial restructuring designed to clean up its balance sheet—removing $900 million in bank debt from MGM's books and reducing its debt-to-equity ratio to (1-to-2)i from (15-to-1)2—with a view toward a future sale of the company. McCarthy (1996) has also performed an analysis of errors while conducting an evaluation on the MUC-5 English Joint Venture (EJV) corpus. A large number of the spurious links are caused by what he terms &quot;feature ambiguity,&quot; which means that feature values are not computed perfectly. As seen in Table 5, our string match feature accounts for most of the spurious links. Also, seven of the spurious links are caused by alias and apposition determination. As with RESOLVE, &quot;feature ambiguity&quot; is the main source of precision errors. For RESOLVE, a large number of the missing links are caused by &quot;incomplete semantic knowledge&quot; (32%) and &quot;unused features&quot; (40.5%). For our system, the errors due to the inadequacy of surface features and semantic class determination problems account for about 75% of the missing links. &quot;Unused features&quot; means that some of the features, or combinations of features, that are needed to classify pairs of phrases as coreferential are not present in the decision trees (McCarthy 1996). Similarly, the inadequacy of our system's surface features means that the current feature set may not be enough and more information sources should be added. Because a detailed error analysis of RESOLVE would require not only its MUC-6 response file, but also the output of its various components, we cannot perform the same error analysis that we did for our system on RESOLVE.
6.. There is a long tradition of work on coreference resolution within computational linguistics, but most of it was not subject to empirical evaluation until recently. Among the papers that have reported quantitative evaluation results, most are not based on learning from an annotated corpus (Baldwin 1997; Kameyama 1997; Lappin and Leass 1994; Mitkov 1997). To our knowledge, the research efforts of Aone and Bennett (1995), Ge, Hale, and Charniak (1998), Kehler (1997), McCarthy and Lehnert (1995), Fisher et al. (1995), and McCarthy (1996) are the only ones that are based on learning from an annotated corpus. Ge, Hale, and Charniak (1998) used a statistical model for resolving pronouns, whereas we used a decision tree learning algorithm and resolved general noun phrases, not just pronouns. Similarly, Kehler (1997) used maximum entropy modeling to assign a probability distribution to alternative sets of coreference relationships among noun phrase entity templates, whereas we used decision tree learning. The work of Aone and Bennett (1995), McCarthy and Lehnert (1995), Fisher et al. (1995), and McCarthy (1996) employed decision tree learning. The RESOLVE system is presented in McCarthy and Lehnert (1995), Fisher et al. (1995), and McCarthy (1996). McCarthy and Lehnert (1995) describe how RESOLVE was tested on the MUC5 English Joint Ventures (EJV) corpus. It used a total of 8 features, 3 of which were specific to the EJV domain. For example, the feature JV-CHILD-i determined whether i referred to a joint venture formed as the result of a tie-up. McCarthy (1996) describes how the original RESOLVE for MUC-5 EJV was improved to include more features, 8 of which were domain specific, and 30 of which were domain independent. Fisher et al. (1995) adapted RESOLVE to work in MUC-6. The features used were slightly changed for this domain. Of the original 30 domain-independent features, 27 were used. The 8 domain-specific features were completely changed for the MUC-6 task. For example, JV-CHILD-i was changed to CHILD-i to decide whether i is a &quot;unit&quot; or a &quot;subsidiary&quot; of a certain parent company. In contrast to RESOLVE, our system makes use of a smaller set of 12 features and, as in Aone and Bennett's (1995) system, the features used are generic and applicable across domains. This makes our coreference engine a domain-independent module. Although Aone and Bennett's (1995) system also made use of decision tree learning for coreference resolution, they dealt with Japanese texts, and their evaluation focused only on noun phrases denoting organizations, whereas our evaluation, which dealt with English texts, encompassed noun phrases of all types, not just those denoting organizations. In addition, Aone and Bennett evaluated their system on noun phrases that had been correctly identified, whereas we evaluated our coreference resolution engine as part of a total system that first has to identify all the candidate noun phrases and has to deal with the inevitable noisy data when mistakes occur in noun phrase identification and semantic class determination. The contribution of our work lies in showing that a learning approach, when evaluated on common coreference data sets, is able to achieve accuracy competitive with that of state-of-the-art systems using nonlearning approaches. It is also the first machine learning-based system to offer performance comparable to that of nonlearning approaches. Finally, the work of Cardie and Wagstaff (1999) also falls under the machine learning approach. However, they used unsupervised learning and their method did not require any annotated training data. Their clustering method achieved a balanced Fmeasure of only 53.6% on MUC-6 test data. This is to be expected: supervised learning in general outperforms unsupervised learning since a supervised learning algorithm has access to a richer set of annotated data to learn from. Since our supervised learning approach requires only a modest number of annotated training documents to achieve good performance (as can be seen from the learning curves), we argue that the better accuracy achieved more than justifies the annotation effort incurred.
7.. In this paper, we presented a learning approach to coreference resolution of noun phrases in unrestricted text. The approach learns from a small, annotated corpus and the task includes resolving not just pronouns but general noun phrases. We evaluated our approach on common data sets, namely, the MUC-6 and MUC-7 coreference corpora. We obtained encouraging results, indicating that on the general noun phrase coreference task, the learning approach achieves accuracy comparable to that of nonlearning approaches.
Acknowledgments. This paper is an expanded version of a preliminary paper that appeared in the Proceedings of the 1999 Joint SIGDAT Conference on Empirical Methods in Natural Language Processing and Very Large Corpora. We would like to thank the MUC organizers who made available to us the MUC-6 and MUC-7 data sets, without which this work would have been impossible. We also thank Beth Sundheim for helpful comments on an earlier version of this paper, and Hai Leong Chieu for his implementation of the HMM-based named entity recognition module.