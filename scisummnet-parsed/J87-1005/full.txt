Artificial Intelligence Center SRI International Menlo Park, CA 94025. and Center for the Study of Language and Information Stanford University Stanford, CA 94305 The syntactic structure of a sentence often manifests quite clearly the predicate-argument structure and relations of grammatical subordination. But scope dependencies are not so transparent. As a result, many systems for representing the semantics of sentences have ignored scoping or generated scopings with mechanisms that have often been inexplicit as to the range of scopings they choose among or profligate in the scopings they allow. This paper presents, along with proofs of some of its important properties, an algorithm that generates scoped semantic forms from unscoped expressions encoding predicate-argument structure. The algorithm is not profligate as are those based on permutation of quantifiers, and it can provide a solid foundation for computational solutions where completeness is sacrificed for efficiency and heuristic efficacy. 1 INTRODUCTION present an algorithm that generates quantifier scopings for English sentences. A principal focus of computational linguistics, as a branch of computer science, ought to be the design of algorithms. A large number of algorithms have undoubtedly been devised for dealing with problems every researcher has to face in constructing a natural language system, but they simply have not received wide circulation. These algorithms are part of the &quot;folk culture&quot;, buried in the most technical, unreadable portions of theses, passed among colleagues informally at best, and often reinvented. It should be a practice to publish these algorithms in isolation, independent of a particular implementation or system. This paper constitutes an effort to initiate such a practice. A problem that many natural-language efforts have faced is the recovery of implicit semantic scope dependency possibilities — such as those manifest in quantifiers and modals — from predicate-argument relations and relations of grammatical subordination, which are more or less transparently conveyed by the syntactic structure of sentences. Previous computational efforts typically have not been based on an explicit notion of the range of possible scopings. In response to this problem, we The naive algorithm for generating quantifier scopings is to generate all permutations of the quantifiers. For a sentence with n quantified noun phrases this will generate n! different readings. But for the sentence there are not six different readings, but only five. The reading that is missing is the one in which most samples is outscoped by every representative but outscopes a company. A model for the disallowed reading could include a different company not only for each representative but also for each sample. The reduction in number of readings for a given sentence is not significant for sentence (1), but in the sentence there are only 42 valid readings, as opposed to the 120 readings the naive algorithm would generate, and this Copyright 1987 by the Association for Computational Linguistics. Permission to copy without fee all or part of this material is granted provided that the copies are not made for direct commercial advantage and the CL reference and this copyright notice are included on the first page. To. copy otherwise, or to republish, requires a fee and/or specific permission. constitutes a significant difference indeed. The recent trend in computational linguistics has been to view more and more noun phrases, as well as other constituents, as introducing quantifiers, so that sentences with this much quantificational complexity are not at all unusual. (The immediately preceding sentence, for example, has six or seven quantifiers.) This observation of &quot;illegitimate readings&quot; is not intended as a new or controversial claim about an idiosyncrasy of English. It accords well with semantic judgments about the possibility of such readings. For instance, we find it impossible to view sentence (1) as expressing that for each representative there was a group of most samples which he saw, and furthermore, for each sample he saw, there was a company he was a representative of. We can find the same problem of illegitimate readings in the standard account of the &quot;Cooper storage&quot; mechanism for generating quantifier scopings (Cooper 1983). Cooper's method generates an expression in intensional logic for the illegitimate readings, but the expression contains an unbound variable and a vacuous quantifier.' Finally, the observation follows merely syntactically from the ill-formedness of certain logical form expressions. Let us examine why this is so. The propositional content of a sentence can be seen as combining specifications that restrict the range of quantified entities, together with assertions about the entities so specified. This intuition is often made formal in the use of logical languages that syntactically separate the notion of the range of a quantified expression from its scope by placing the information about the range in a part of the expression we call the restriction and the assertions in a part called the body. (Henceforth, we will uniformly use the terms restriction and body.) The separation of these two semantic roles of range and scope into restriction and body as an important fact of the logical structure of English can be seen, for example, in Woods's four-part quantifier structures (Woods 1977), in the recommendations of Moore (1981), and in the generalized quantifier research of Barwise and Cooper and others. The latter have demonstrated the necessity of such a separation for quantifiers other than the standard first-order ones (Barwise and Cooper, 1981; Cushing, 1976). But under this understanding of English logical structure, it follows that no sixth reading exists for sentence (1) above. Consider the reading in which the universal outscopes the most which outscopes the existential in the logical form for this sentence. Then, using the notation of Moore (1981) for four-part quantifier structures, the logical form must have the following structure: all(r, representative(r) , ...) since the universal is outermost. Now the existential is within the scope of the universal by hypothesis, and since it provides a restriction on the range of the variable r, it must occur in the restriction of the quantifier. Thus, we have: all(r, representative(r) & some(c, company(c), of(c,r)), ...saw(r,$)...) But where can the quantifier most be put to bind the variable s corresponding to the samples seen? It must outscope its occurrence in the body of the universal, but it must also by hypothesis outscope the existential in the restriction of the universal. To outscope both, it must outscope the universal itself, but this violates the assumed scope relations. Thus, no such reading is possible. By a similar argument, it follows from the logical structure of English that in general a quantifier from elsewhere in a sentence cannot come after the quantifier associated with a head noun and before the quantifier associated with a noun phrase in the head noun's complement. Most research in linguistic semantics, e.g., Montague (1973) and Cooper (1983), has concentrated on explicitly defining the range of possible scope relationships that can be manifested in sentences. But, to our knowledge, all fall prey to the profligacy of generation just outlined. We are concerned here only with suppressing readings that are spurious for purely structural reasons, that is, for reasons that follow from the general relationship between the structure of sentences and the structure of their logical forms and independent of the meanings of the particular sentences. For instance, we are not concerned with logical redundancies, such as those due to the commutativity of successive universal quantifiers. When we move beyond the two first-order logical quantifiers to deal with the so-called generalized quantifiers such as most, these logical redundancies become quite rare. Similarly, we are not concerned with the infelicity of certain readings due to lexical semantic or world knowledge, such as the fact that a child cannot outscope every man in the sentence I've met a child of every man in this room. Computational research on quantifier scoping has emphasized generating a single scoping, which can be thought of as heuristically primary, as discussed by, for example, Woods (1977), Pereira (1983), and Grosz et al. (1985). We are concerned not with generating the best reading but with generating all readings. The reader may object that it is inappropriate in a practical natural language system to generate scopings one by one for testing against semantic and pragmatic criteria. Instead, one should appeal to various heuristics to generate only the most likely reading, or at least to generate readings in order of their plausibility. These include the following: relational head noun usually outscopes the head noun; and We are sympathetic with this view. Nevertheless, there are several reasons that codifying a complete algorithm remains useful. First, a complete and sound algorithm provides a benchmark against which other approaches can be tested. Second, one may actually wish to use a generate-and-test mechanism in simpler implementations, and it should be correct and as efficient as possible. It should not generate scopings that can be ruled out on purely structural grounds. Finally, the algorithm we present might be modified to incorporate heuristics to generate scopings in a certain order or only certain of the scopings. The soundness and correctness of the underlying algorithm, provide a guarantee of soundness for a heuristically guided version. We include a few comments below about incorporating ordering heuristics into our scoping generation algorithm, although we should point out that the possibilities are somewhat limited due to the local nature of where the heuristics can be applied. A full discussion of heuristically-guided scoping generation is, of course, beyond the scope of this paper.
1.2.3 SCOPE OF OPAQUE PREDICATES. In addition to handling the scoping of quantifiers relative to each other, the algorithm we present also allows quantifiers to be scoped within or outside of opaque arguments of higher-order predicates. For instance, the algorithm generates two readings for the sentence Everyone isn't here. corresponding to the two relative scopings of the universal quantifier and the negation.
2 THE ALGORITHM. In the discussion below, we assume that parsing has made explicit the predicate-argument relations and the relations of grammatical subordination in the form of a logical encoding in an input language. A well-formed formula (wff) in the input language is a predicate or other operator applied to one or more arguments. An argument can be a constant or variable, another wff, or what we will call a complex term. A complex term is an ordered triple consisting of a quantifier, a variable, and a wff (called the restriction), which represents the predication that is grammatically subordinated to the variable. The input representation for sentence (2) is, then, the following (ignoring tense): A complex term can be read &quot;quantifier variable such that restriction&quot;, e.g., &quot;most c such that c is a company&quot;. The output language is identical to the input language, except that it does not contain complex terms. Quantifiers are expressed in the output language as operators that take three arguments: the variable bound by the quantifier, a wff restricting the range of the quantified variable, and the body scoped by the quantification, schematically quantifier(variable, restriction, body) This encoding of quantification is the same as that found in Woods (1977) and Moore (1981). We will refer to such expressions as quantified wffs. Thus, one reading for sentence (2) is represented by the following quantified wff: Intermediate structures built during the course of scoping include both complex terms and quantified wffs. We use the term full scoping for an expression in the output language, i.e., one that has no complex terms. We also will use the terms bound and free as follows: An expression binds a variable v if the expression is of the form < q v r> or q(v, r, s) where g is a quantifier. The variable v is said to be bound in the expressions r, or r and s, respectively. A variable v is unbound or free in an expression a if there is an occurrence of v in a that is not also an occurrence in a subexpression of a binding v. Note that here quantified wffs and complex terms are both thought of as expressions binding a variable. We present both nondeterministic and deterministic versions of the algorithm3 in an ALGOL-like language. Both algorithms, however, have the same underlying structure, based on the primitive operation of &quot;applying&quot; a complex term to a wff in which it occurs: a complex term in a wff is replaced by the variable it restricts, and that variable is then bound by wrapping the entire form in the appropriate quantifier. Thus, applying the term <q x r(x) > to a wff containing that complex term, say, p( <q x r(x) > ), yields the quantified wff Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 49 Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings q(x, r(x), p(x)). This is the primitive operation by which complex terms are removed from a wff and quantified wffs are introduced. It is implemented by the function apply. The generation of a scoping from a wff proceeds in two stages. First, the opaque argument positions within the wff are scoped. The function pull-opaque-args performs this task by replacing wffs in opaque argument positions by a (full or partial) scoping of the original wff. For instance, if p were a predicate opaque in its only argument, then, for the wff p(s( <q x r(x) > )), pullopaque-args would generate the wff p(q(x, r(x), s(x))) or the unchanged wff p(s( < q x r(x) > )). In the former, the opaque predicate p outscopes the quantifier q. In the latter, the quantifier q has not been applied yet and the wff will subsequently yield readings in which q has wider scope than p. Second, some or all of the remaining terms are applied to the entire wff. The function apply-terms iteratively (through a tail recursion) chooses a complex term in the wff and applies it. Thus apply-terms acting upon the wff depending on how many quantifiers are applied and in what order. The choice of a complex term is restricted to a subset of the terms in the wff, the so-called applicable terms. The principal restriction on applicable terms is that they not be embedded in any other complex term in the wff. Section 4.1 discusses a further restriction. The function applicable-term returns an applicable term in a given wff. These two stages are manifested in the function pull which generates all partial or full scopings of a wff by invoking pull-opaque-args and apply-terms. Since ultimately only full scopings are desired, an additional argument to pull and apply-terms controls whether partial scopings are to be returned. When this flag, complete?, is true, apply-terms, and hence pull, will return only expressions in which no more complex terms remain to be applied, for example, only the last two of the five readings above. Finally, the restrictions of the complex terms may themselves contain complex terms and must be scoped themselves. The apply function therefore recursively generates the scopings for the restriction by calling pull on that restriction, and a quantified wff is generated for each possible partial or complete scoping of the restriction. Schematically, in the simplest case, for the A subsequent application of the remaining complex term will yield the &quot;wide scope&quot; reading q2(y, r2(y), qi(x, ri(xty), p(x)) The disallowed readings produced by the &quot;all permutations&quot; algorithm are never produced by this algorithm, because it is everywhere sensitive to the four-part quantifier structure of the target logical form. The difference between the nondeterministic and deterministic versions lies only in their implementation of the choice of terms and returning of values. This is done either nondeterministically, or by iterating through and returning explicit sets of possibilities. A nondeterministic Prolog version and a deterministic COMMON LISP version of the algorithm are given in Appendices A and B. The full text of these versions (including auxiliary functions not listed here) is available from the authors. A variant of the COMMON LISP version is currently being used at SRI International to generate scopings in the KLAUS system. In the specifications below, the let construct implements local variable assignment. All assignments are done sequentially, not in parallel. The syntax is let (assignments) in (body) The entire expression returns what the body returns. Destructuring by pattern matching is allowed in the assignments; for example, let <quant var restrict> := term in (body) simultaneously binds quant, var, and restrict to the three corresponding components in term. The symbol &quot;:=&quot; is used for assignment. lambda is an anonymous-functionforming operator. Its syntax is lambda( (variable)). (body) where (variable) is free in (body). We assume lexical scoping in lambda expressions. The statement &quot;return value&quot; returns a value from a function. The binary function map (similar to LISP's mapcar) applies its second argument (a lambda expression) to each of the elements of its first argument (a list). It returns a corresponding list of the values of the individual applications. The function integers(lower,upper) returns a list of the integers in the range lower to upper, inclusive and in order (corresponding to APL's iota). The function length(list) is obvious. The expression list!n! returns the nth element of the list list. The function subst(x,y,expr) substitutes x for all occurrences of y in expr. The unary function predicate(wff) returns the main predicate in a wff. The unary function arguments(wff) returns a list of the arguments in a wff. Applied to two arguments, wff is a binary function that takes a predicate name and a list of arguments, and returns the wff consisting of the application of the predicate to the arguments. Applied to four arguments, wff is a quaternary function that takes a quantifier name, a variable name, a restriction, and a body, and returns the quantified wff consisting of the binding of the variable by the quantifier in the restriction and body. The binary predicate opaque(predicate, n) returns true if and only if the predicate is opaque in its nth argument. It is naturally assumed that opaque argument positions are filled by wff expressions, not terms. Each of the unary predicates wff?, term?, and quantifier? returns true if and only if its argument is a wff, a complex term, or a quantifier operator, respectively. In the nondeterministic version of the algorithm, there are three special language constructs. The unary predicate exists(expression) evaluates its argument nondeterministically to a value and returns true if and only if there exist one or more values for the expression. The binary operator &quot;ail b&quot; nondeterministically returns one of its arguments (a or b). The function term(form) nondeterministically returns a complex term in form. Finally, the function applicable-term(form) nondeterministically returns a complex term in form that can be applied to form. The nondeterministic version of the algorithm is as follows. The function gen(form) nondeterministically returns a valid full scoping of the formula form. function gen (form); return pull(form,true). The function pull(form,complete?) nondeterministically returns a valiciscoping of the formula form. If complete? is true, then only full scopings are returned; otherwise, partial scopings are allowed as well. The function pull-opaque-args(form), when applied to a wff, returns a wff generated from form but with arguments in opaque argument positions replaced by a valid scoping of the original value. Since the recursive call to pull has complete? set to false, the unchanged argument is a nondeterministic possibility, even for opaque argument positions. When applied to any other type of expression (i.e., a term of some sort), form is unchanged. function pull-opaque-args(form); if not(wff.2(form)) then return form else let predicate := predicate(form); The function apply-terms(form, complete?) chooses function apply-terms(form, complete? ); several terms in form nondeterministically and applies if not(exists(term(form))) them to form. If complete? is true, then only full scopings then return form are returned. else let scoped-form := apply-terms(apply(applicable-term(form), form), complete?) in if complete? then return scoped-form else return scoped -form II form. Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 51 Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Seopings The function apply(term, form) returns a wff consisting of the given complex term term applied to a form form in which it occurs. In addition, the restriction of the complex term is recursively scoped. function apply(term,form); let <quant var restrict> := term return wff(quant, var, pull(restrict,false), subst(var,term,form)). For the deterministic version of the algorithm, there are five special language constructs. The unary predicate empty(set) returns true if and only if set is empty. Paired braces &quot;I ... I&quot; constitute a set-forming operator. The binary function union applies its second argument (a lambda expression) to each of the elements of its first argument (a set). It returns a corresponding set of the values of the individual applications. The binary infix operator U returns the union of its two arguments (both sets). The function cross-product takes a list of sets as its argument and returns the set of lists corresponding to each way of taking an element from each of the sets in order. For example, The function terms(form) returns the set of all complex terms in form. The function applicable-terms(form) returns the set of all complex terms in form that can be applied to form. The deterministic version of the algorithm is identical in structure to the nondeterministic version. Each function operates in the same way as its nondeterministic counterpart, except that they uniformly return sets rather than nondeterministically returning single values. The algorithm is as follows. The function gen (form) returns a set of all valid full scopings of the formula form. function gen (form); return pull(form,true). The function pull returns a set of all valid scopings of the formula form. If complete? is true, only full scopings are returned; otherwise, partial scopings are allowed as well. The function pull-opaque-args(form) returns a set of all wffs generated from form, but with arguments in opaque argument positions replaced by a valid scoping of the original value. Since the recursive call to pull has complete? set to false, the unchanged argument is a possibility even for opaque argument positions. When applied to any other type of expression (i.e., a term of some sort), the argument is unchanged. The function apply-terms (form, complete?) returns a set of scopings of form constituting all of the ways of choosing several terms in form and applying them to form. If complete? is true, then only the full scopings are returned. The function apply(term, form) returns a set of all wffs consisting of the given complex term term applied to the form form in which it occurs, with the restriction of the complex term recursively scoped in all possible ways. function apply(term,form); let (quant var restrict) := term in return
3 Two EXAMPLES. Since the algorithm is not completely transparent, it may be useful to work through the deterministic version for a detailed example. The predicate-argument structure of this sentence may be represented as follows: Suppose gen is called with expression (6) as form. Since this is the representation of the whole sentence, pull will be called with complete? equal to true. The call to pullopaque-args will return the original wff unchanged since there are no opaque operators in the wff. We therefore call apply-terms on the wff. In apply-terms, the call to applicable-terms returns a list of all of the unnested complex terms. For (6), there will be two: Each of these complex terms will ultimately yield the wffs in which its variable is the more deeply nested of the two. The function apply is called for each of these complex terms, and inside apply there is a recursive call to pull on the restriction of the complex term. This generates all the possible scopings for the restriction. When apply is called with (6) as form and (7) as term, the result of scoping the restriction of (7) will be the following four wffs: Because this call to pull has complete? equal to false, the unprocessed restriction itself, wff (9), as well as the partially scoped wff (10), is returned along with the fully scoped forms of the restriction. Wff (9) will ultimately generate the two readings in which variables d and c outscope r. Wff (10) is also partial as it still contains a complex term. It will ultimately yield a reading in which r outscopes d but is outscoped by c; the complex term for c is still available for an application that will give it wide Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 53 Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings scope. Wffs (11) and (12) will ultimately yield readings in which d and c are outscoped by r. Each of these wffs becomes the restriction in a quantified wff constructed by apply. Thus, from restriction (10), apply will construct the quantified wff (13) some(r, every(d, and(dept(d), in(d, <most c and(rep(r), of(r, d))), see(r, <a-few s samp(s)>)) In apply-terms, the tail recursion turns the remaining complex terms into quantifiers with wide scope. Thus, in (13) c and s will be given wider scope than r and d. For example, one of the readings generated from wff (13) will be Sentence (5), by the way, has 14 different readings. As an example of the operation of the algorithm on a wff with opaque operators, we consider the sentence Everyone isn't here. This has the predicate-argument structure not(here(<every x person(x)>)) where not is an operator opaque in its only argument. The call to pull-opaque-args returns the two scopings not(here(<every x person(x)>)) not(every(x,person(x),here(x))) The call to apply-terms then turns the first of these into every(x,person(x),not(here(x))) Thus, the following two full scopings are generated: every(x,person(x),not(here(x))) not(every(x,person(x),here(x))) Note that because of the recursive call in pull-opaque-args these two readings will be generated even if this form is embedded within other transparent predicates.
4 MODIFICATIONS AND EXTENSIONS 4.1 RESTRICTING APPLICABLE TERMS. The notion of applicable term used above was quite simple. A complex term was applicable to a wff if it was embedded in no other complex term within the wff. The restriction is motivated by the following consideration. Suppose the input wff is the remaining complex term would include a free occurrence of y so that when it is later applied, resulting in the formula the variable y occurs free in the restriction of q, . Thus, it is critical that a term never be applied to a form when a variable that is free in the term is bound outside of it in the form. The simple definition of applicability goes part of the way towards enforcing this requirement. Unfortunately, this simple definition of applicability is inadequate. If x had itself been free in the embedded complex term, as in the wff the application of the outer term followed by the inner term would still leave an unbound variable, namely x. This is because the inner term, which uses x, has been applied outside the scope of the binder for x. Such structures can occur, for instance, in sentences like the following, where an embedded noun phrase requires reference to its embedding noun phrase.5 Every man that I know a child of has arrived. Every man with a picture of himself has arrived. In these two sentences the quantifier a cannot outscope every because the noun phrase beginning with a embeds a reference to every man. If a were to outscope every, then himself or the trace following child of would be outside the scope of every man. The definition of applicable term must be modified as follows. A term in a wff is applicable to the wff if and only if all variable occurrences that are free in the term are free in the wff as well. Our previous definition of applicability, that the term be unembedded in another term in the wff, is a simple consequence of this restriction. The versions of the algorithm given in Appendices A and B define the functions applicable-term and applicable-terms in this way. Given this definition, the algorithm can be shown never to generate unbound variables. (See Appendix C.) A full discussion of heuristic rules for guiding generation of quantifier scopings is outside of the aims of this paper. However, certain ordering heuristics can be incorporated relatively easily into the algorithm merely by controlling the way in which nondeterministic choices are made. We discuss a few examples here, merely to give the flavor for how such heuristics might be added. For instance, suppose we want to favor the original left-to-right order in the sentence. The function applicable-terms should return the complex terms in right-to-left order, since quantifiers are extracted from the inside out. The union in line (3) should return form after scopedforms. If we want to give a noun phrase wide scope when it occurs as a prepositional phrase noun complement to a function word, e.g., every side of a triangle, then form should come before scoped-form in line (3) when pull has been called from line (4) in apply where the first argument to apply is a complex term for a noun phrase satisfying those conditions, e.g., the complex term for every side of a triangle. The modifications turn out to be quite complicated if we wish to order quantifiers according to lexical heuristics, such as having each outscope some. Because of the recursive nature of the algorithm, there are limits to the amount of ordering that can be done in this manner. At the most, we can sometimes guarantee that the best scoping comes first. Of course, one can always associate a score with each reading as it is being generated and sort the list afterwards. The algorithm as presented will operate correctly only for input structures that are themselves well-formed. For instance, they must contain no unbound variables. Certain natural language phenomena, such as the so-called donkey sentences, exhibit structures that are ill-formed with respect to the assumptions made by this algorithm. For instance, the sentence Every man who owns a donkey beats it. has an ill-formed input structure because the pronoun has to reach inside the scope of an existential quantifier for its antecedent. Its predicate-argument structure might be something like An alternative is to leave the pronoun unanalyzed, in which case the closest reading produced by the algorithm is In fact, this is not bad if we take it(x) to mean that x is nonhuman and that x is mentioned in the prior discourse in a position determined by whatever coreference resolution process is used. There is a problem if we take the quantifier the to mean that there is a unique such x and take the sentence to mean that a man who owns many donkeys will beat every donkey he owns. But we can get around this if, following the approach taken by Hobbs (1983), we take a donkey to be generic, take it to refer to the unique generic donkey that m owns, and assume that to beat a generic donkey is to beat all its instances. In any case, modifications to the algorithm would be needed to handle such anaphora phenomena in all their complexity.
5 CONCLUSION. We have presented an algorithm for generating exactly those quantifier scopings that are consistent with the logical structure of English. While this algorithm can sometimes result in a significant savings over the naive approach, it by no means solves the entire quantifier scoping problem, as we have already pointed out. There has already been much research on the problem of choosing the preferred reading among these allowable ones, but the methods that have been suggested need to be specified in an implementation-free fashion more precisely than they have been previously, and they need to be evaluated rigorously on large bodies of naturalistic data. More important, methods need to be developed for using pragmatic considerations and world knowledge — particularly reasoning about quantities and dependencies among entities — to resolve quantifier scope ambiguities, and these methods need to be integrated smoothly with the other kinds of syntactic, semantic, and pragmatic processing required in the interpretation of natural language texts.
ACKNOWLEDGMENTS. We have profited from discussions about this work with Paul Martin and Fernando Pereira, and from the comments of the anonymous reviewers of the paper. This research was supported by NIH Grant LM03611 from the National Library of Medicine, by Grant IST-8209346 from the National Science Foundation, and by a gift from the System Development Foundation.
APPENDIX A. PROLOG IMPLEMENTATION OF THE ALGORITHM. The following is the core of a Prolog implementation of the nondeterministic algorithm which includes all but the lowest level of routines. The syntax is that of Edinburgh Prologs, e.g., DEC-20 Prolog. Representation of wffs: A wff of the form 'p(argl,...,argn)' is represented as the Prolog term wff(p,[arg1',...,argn1) where argi' is the encoding of the subexpression argi. A constant term is represented by the homonymous Prolog constant. A complex term is represented by the Prolog term term(quant,var,restrict') where restrict' is the encoding of the wff that forms the restriction of the quantifier. Form ==> a wff with in-place complex terms Complete? ==> true iff only full scopings are allowed ScopedForm <== a full or partial scoping of Form Applies terms at various level of embedding in Form, including applying to the entire Form, and to opaque argument positions inside Form. Form ==> a term or a wff with in-Place complex terms ScopedForm <== Form with opaque argument positions recursively scoped Scopes arguments of the given Form recursively. % pull_opaque_args(Pred, ArgIndex, Args, ScopedArgs) the wff whose args are being scoped argument currently being scoped ArgIndex on argument positions recursively scoped Scopes a given argument if opaque; otherwise, scopes its subparts recursively. % No more arguments. pull_opaque_args(_Pred,_ArgIndex,H,H) !. % Current argument position is opaque; scope it. pull_opaque_args(Pred, ArgIndex, Form ==> a wff with in-place complex terms Complete? ==> true iff only full scopings are allowed ScopedForm <== a full or partial scoping of Form Applies one or more terms to the Form alone (not to any embedded forms. apply_terms(Form, _Complete, Form) :not(term(Form,_Term)), !. % apply(Term,Form,NewForm) Term ==> a complex term Form ==> the wff to apply Term to NewForm <== Form with the quantifier wrapped around it apply(term(Quant,Var,Restrict), Body, wff(Quant,[var,PulledRestrict,OutBody])) :pull(Restrict, false, PulledRestrict), subst(Var,term(Quant,Var,Restrict),Body,OutBody). % applicable_term(Form, Term) Form ==> an expression in the logical form language Term <== a top-level term in Form (that is, a term embedded in no other term) which is not free in any variable bound along the path from Form to the Term. Form ==> an expression in the logical form language Term <== a top-level term in Form (that is, a term embedded in no other term) which is not free in any variable bound along the path from Form to the Term. BlockingVars ==> a list of variables bound along the path so far % A term is an applicable top-level term... applicable_term(term(Q,V,R),term(Q,V,R), BVs) % if it meets the definition. not(free_in(BVs, R)). % An applicable term of the restriction or body of a quantifier is applicable % only if the variable bound by the quantifier is not free in the term. applicable_term(wff(Quant,[Var,Restrict,Body]),Term, BVs) :quantifier(Quant), !, (applicable_term(Restrict,Term,[VarIBVs]); applicable_term(Body,Term,[VarIBV0). % Note the absence of a rule looking for applicable terms inside of % complex terms. This limits applicable terms to be top-level.
APPENDIX B.. The following is the core of a COMMON LISP implementation of the deterministic algorithm which includes all but the lowest level of routines. ;;;. ***************************************************************************
COMMON LISP Implementation of Scope Generation Algorithm. ;;; A wff of the form 'p(argl,...,argn)' is represented as the ;;; s-expression (p argi' argn') where argi' is the encoding of the ;;; subexpression argi. A constant term is represented by the homonymous LISP atom. A complex term is represented by the s-expression (:term quant ;;; var restrict') where restrict' is the encoding of the wff that forms ;;; the restriction of the quantifier. Implementation notes: ;;; The following simple utility functions are assumed: ;;; map-union -- implements the binary function UNION ;;; cross-product -- implements the function CROSS-PRODUCT opaque -- implements the binary function OPAQUE ;;; integers -- implements the binary function INTEGERS ;;; The infix union is implemented with CL function UNION. ;;; The binary prefix union is implemented under the name MAP-UNION ;;; to avoid conflict with the CL function UNION. ;;; The function APPLY is implemented under the name APPLY-Q to avoid ;;; conflict with the CL function APPLY.
APPENDIX C. PROOFS OF ALGORITHM PROPERTIES. This appendix includes informal proofs of some important properties of the nondeterminisitc version of the presented algorithm. First, we present a proof of the termination of the algorithm. Several criteria of the partial correctness of the algorithm are also informally shown, especially, that the algorithm does not generAte wffs with unbound variables. However, we do not prove correctness in the sense of showing that the algorithm is semantically sound, i.e., that it yields wffs with interpretations consistent with the interpretation of the input expression, simply because we do not provide a semantics for the input language. (The output language, of course, has a standard logical semantics.) We do not attempt to prove completeness for the algorithm, as the concept of completeness is open to interpretation, depending as it does on just which scopings one deems possible, but we expect that the algorithm is complete in the sense that every permutation of quantifiers respecting the considerations in the introduction is generated. We also do not prove the nonredundancy of the nondeterminism in the algorithm, i.e., that the algorithm will not generate the same result along different nondeterministic paths, although we believe that the algorithm is nonredundant.
C.1 NOTATION. We will use lower Greek letters (a, /3, ...) as variables ranging over expressions in the logical form language. We inductively define a metric p on expressions in the logical form language as follows: We will give an informal proof of termination for the nondeterministic algorithm by induction on this metric p. But first, we present without proof three simple but useful properties of the metric. Lemma 1 If a is a wff, then p(a) = 0 if and only if a contains no complex terms. Lemma 2 If a is a wff and 0 is a subexpression of a and p(a) > 0, then p(P) < p(a) Lemma 3 If a is a wff and /3 is a subexpression of a and p(a) = 0, then p(i3) = 0. We now prove the following theorem, and its corollary which gives the termination of the algorithm. We assume that calls to the auxiliary functions wff, term, wff?, term?, Proof: We first prove the base case, for p(a) = 0. By Lemma 1, a must contain no complex terms. Three of the conditions are easily proved. Condition 2: Since, by Lemma 1, there are no complex terms in a, this condition holds vacuously. Condition 3: Again, the absence of complex terms in a causes the call to apply-terms to return with result a, and p(a) = 0, so the condition holds. Condition 4: Similarly, and p(a) < p(a) trivially. Conditions 1,5, and 6: These conditions follow directly from Lemma 4 given below. Lemma 4 For all expressions a such that p(a) = 0, pull(a,x) and pull-opaque-args(a) terminate with result a. Proof sketch: The proof is by a simple induction on the length of the expression, and uses the base case for conditions 3 and 4 proved above. For the induction step for Theorem 1, we assume the induction hypotheses that the six conditions hold for all a such that p(a) < n and prove the conditions for p(a) = n, for n>0. The conditions are proved sequentially. In particular, earlier conditions for the case p(a) = n are used in the proofs of later ones. (Since there is no use of later conditions in earlier ones, this does not introduce any circularity in the proof.) Condition 1: We must show that pull-opaque-args(a) terminates with result (3 such that p(13) < p(a). If a is not a wff, then the condition holds vacuously, so we assume that a = f(cei, ,a,). By definition of p, (The inequality is necessary because p(f3) may be zero.) Now /3, is either a, or pull(a,false). In the first case, p(1t) < p(a,) trivially. In the second case, since a, is a subexpression of a, by Lemma 2 we have that p(a,) < p(a) and we can use the induction hypothesis to show the termination of the call to pull. Also by the induction hypothesis, p(f11) < p(a,). Thus, we see that in either case, p(A) < p(a,). So Condition 2: We must show that for all terms t in a, apply(t,a) terminates with result p such that p(I3) < p(a). Suppose t=<qvr>. Then = aPP1.YRq v r>, a) = q(v, y, 8) where y = pull(r, false) and 8 = subst(v, <q v r>, a). Now, let p(r) = m. By Lemma 2, m <n. So by the induction hypothesis, the computation of y terminates and p(y) < m. Also, the computation of 8 is assumed to terminate (as mentioned above) with 8 missing the complex term t that occurs in a (and possibly other complex terms embedded within 1). So Finally, by definition of p we have p(fl) < 1 + p(y) + p(8)<1+m+n— 2 —m=n-1<n. We will use the two conditions just proved in the proofs of the final four conditions. Condition 3: We must show that apply-terms(a,true) terminates with result /3 such that p(13) = 0. By Lemma 1, we know that complex terms exist in a so the else clause is taken. Let t = applicable-term(a) and y = apply(t,a). By the second condition just proved above, the latter computation terminates with p(y) < p(a) — 1 < n. Now let E = apply-terms(y, true). Again, by the induction hypothesis, this computation terminates with p( €) = 0. Since complete? = true, we return c as g, so p(P) = 0 as required. Condition 4: We must show that apply-terms(a false) terminates with result 13 such that p([3) < p(a). By Lemma 1, we know that complex terms exist in a so the else clause is taken. Let t = applicable-term(a) and y = apply(t,a). By the second condition just proved above, this computation terminates with p(y) < p(a) — 1 < n. Now let E = apply-terms(y false). Again by the induction hypothesis, this computation terminates with p(E) < p(y) < n. Since complete? = false, we return E or a as p. In either case, p(I3) < p(a) as required. We will use the four conditions just proved in the proofs of the final two conditions. Condition 5: We must show that pull(a,true) terminates with result g such that p(13) = 0. Let y = pull-opaqueargs(a). By the first condition just proved above, we know this computation terminates and p(y) <n. Now, let E = apply-terms(y,true). Again by the third condition just proved above, this computation terminates with p(E) = 0. Since complete? = true, we return E as 0, so p(P) = 0 as required. Condition 6: We must show that pull(a false) terminates with result /3 such that p([3) < p(a). The argument is similar to that for condition 5. Let y = pull-opaqueargs(a). By the first condition just proved above, we know this computation terminates and p(y) < n. Now, let E = apply-terms(y, false). Again by the fourth condition just proved above, this computation terminates with p(E) < p(y) < n. Since complete? = false, we return either E or a as p. In either case, p(13) < p(a) as rquired. This completes the proof of the six conditions, given the induction hypotheses, and thus completes the inductive proof of the theorem. Corollary 1 For all wffs a, gen(a) terminates with result g such that [3 has no complex terms as subexpressions. Proof: This follows immediately from the fifth condition in Theorem 1 and Lemma 1. Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 61 Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Seopings
C.3 CORRECTNESS. We consider several criteria for correctness of the algorithm. Let U(a) = the set of variables that are unbound in a and V(a) = the set of variables that are vacuously quantified in a.6 We show that if input expression a is well-formed, that is, has no unbound variables and no vacuous quantifiers ( U(a) = V(a) = 0), and if /3 = gen(a), then Criterion 4: for every complex term t in a, there is a quantifier in [3 that binds the same variable as t and has the position held by tin a in its body; and Criterion 5: for every quantifier q in g, there is either a quantifier in a or a complex term in a that binds the same variable. Proof of these five statements does not constitute a proof of correctness, but provides motivation for assuming the correctness of the algorithm. As unbound variables in the output are the prime symptom of problems with previous algorithms, we take these criteria to be the most critical for indicating correctness. The first criterion follows directly from Corollary 1. The second and third criteria are a consequence of the following theorem which we prove informally. Theorem 2 For all expressions such that U(a) = u = , um' and V(a) = v = , v,j, and for b E {true, falsel and for 0 any of gen(a), pull(a, b), pull-opaque-args(a), apply-terms(a, b), and apply(applicable-term(a), a), u(g) = u and V(P) = v. Proof: Again, the proof is by induction on p(a), but we will be less formal in demonstrating the well-foundedness of the induction. The base case is trivial because, as shown in the proofs of Theorem 1 and Lemma 4, the functions all return their argument unchanged when p(a) = 0. For the induction step, we will merely show that each function maintains the unbound variables and vacuous quantifiers, assuming that all the others do. The previous proof of termination provides the well-foundedness of this proof. apply(applicable-term(a),a): We must show that if t= <qxr> is an applicable term in a and U(a)=u and V(a) = v then U(apply(t,a)) = u and V(apply(t,a)) = v as well. The unbound variables u in a can be divided into two (possibly overlapping) sets u, and u„ where u, consists of those variables in u that occur in r and u, consists of those variables in u that occur outside of t in a. Note that u = u, U u,. Now assume x occurs in r. Then U(r) = {x} U u„U uo where 140 is the set of variables bound within a but outside of t and which occur free in r. But t is an applicable term, and by the definition of &quot;applicable term&quot; uo must be empty. So U(r) = {x} U u„. (If x does not occur in r, a similar argument shows that U(r) = u,.) Let r' = pull(r, false) and s = subst(x,t,a). By the induction hypothesis, U(r') = fx1 U ur. Since s does not include t (which binds x) but does include x, U(s) = 1x1 U u. In forming the quantified wff /3 = q(x, , s), the unbound variables in g consist of those in and those in s except for x, that is Vacuous quantified variables can be divided similarly into v. (those bound vacuously in r) and v, (those bound vacuously outside of t in a). Again, v = v, U v,. Trivially, V(r) = v„. By induction, V(I) = v, also. Since s does not include t, V(s) = v,. V(I3) = V(r) U V(s) = v unless the quantification of x in 13 is vacuous. Since x is guaranteed to occur in s (as it replaces t in s), the quantification is clearly not vacuous. So v(0) = v. apply-terms(a,b): This follows straightforwardly from the previous subproof for apply and the induction hypothesis for apply-terms. pull-opaque-args(a): If a is not a wff, then the proof is trivial. Otherwise, there are two cases, depending on whether the predicate in a, p, is or is not a quantifier. If p is not a quantifier, then the result follows immediately from the induction hypothesis for pull and pullopaque-args. If p is a quantifier, then let a = p(x,r,$). The output 13 then is wff(p, pull-opaque-args(x), pullopaque-args(r), pull-opaque-args(s)). The first call to pull-opaque-args merely returns x. Now by an argument similar to that given in the subproof for apply, the unbound variables in a can be exhaustively divided into u, and u, depending on whether they occur in r and s. Depending on whether x occurs in r, U(r) = fx1 U u, or U(r) = ur. Similarly, U(s) = {x} U u, or U(s) = u,. Suppose the second and third calls to pull-opaque-args return r' and s' respectively. By the induction hypotheses U(I) = U(r) and U(s') = U(s). If the quantification of x in a is not vacuous, then x occurs free in either r or s (and by induction in or s') so u(p) = {x} U u, U u, — {xl = u. If the quantification of x is vacuous, then U(r') = u, and U(s') = u, and Vacuous quantified variables can be divided into v„ and vs similarly. Suppose the quantification of x is vacuous (i.e., x does not occur free in r or s). Then V V(a) = {x} U v, U v. By the induction hypothesis, V(I) = V(r) = v, and V(s') = V(s) = v,. Also by induction, x does not occur free in or s'. Therefore, the quantification of x in p is also vacuous and V(13) = {x} U v,U v, = V(a). If the quantification of x is not vacuous, then v = v, U v, and x occurs free in either r or s. By inducation, x occurs free in either or s' so the quantification of x in g is also non-vacuous. Also by induction as before, V(I) = v,. and V(s') = v„ so pull(a,b): This follows directly, using the previously proved induction steps for apply-terms and pullopaque-args. gen(a): This follows directly, using the previously proved induction step for pull. This concludes the proof of the induction step and the theorem. The second and third criteria follow from the presumed well-formedness of a and Theorem 2 which demonstrates that gen maintains well-formedness. The fourth and fifth criteria we argue informally as follows: Since no complex terms occur in g (by Corollary 1), we can assume that every complex term t in a was applied (i.e., the first argument of apply) at some time in the processing of a. But if it was applied, then it must have been an applicable term occurring in the wff it was applied to (as the only call to apply is of this form). Then the call to subst in apply will not be vacuous, the quantifier will bind the same variable as t and will outscope the position held by t in a. Thus the fourth criterion holds. Also note that all quantifiers in ,13 are either the result of such an application or were in a originally. Thus the fifth criterion follows immediately as well.